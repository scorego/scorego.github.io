<!DOCTYPE html>













<html class="theme-next mist" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/favicon-128x128-01.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-01.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-01.ico?v=7.1.0">


  <link rel="mask-icon" href="/uploads/favicon-128x128-01.ico?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Spring Framework GithubSpring Framework Documentation : Web Servlet - Version 5.1.6.RELEASE Ⅰ. Spring Web MVCSpring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。其正式名称Spring Web MVC来自它的源模块">
<meta name="keywords" content="Spring Framework,Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC">
<meta property="og:url" content="javior.wang/2019/05/05/backends/spring/Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC/index.html">
<meta property="og:site_name" content="Javior&#39;s Blog">
<meta property="og:description" content="Spring Framework GithubSpring Framework Documentation : Web Servlet - Version 5.1.6.RELEASE Ⅰ. Spring Web MVCSpring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。其正式名称Spring Web MVC来自它的源模块">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="/images/backend/spring/springframework/03-01-mvc-context-hierarchy.png">
<meta property="og:updated_time" content="2019-05-15T05:23:20.493Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC">
<meta name="twitter:description" content="Spring Framework GithubSpring Framework Documentation : Web Servlet - Version 5.1.6.RELEASE Ⅰ. Spring Web MVCSpring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。其正式名称Spring Web MVC来自它的源模块">
<meta name="twitter:image" content="/images/backend/spring/springframework/03-01-mvc-context-hierarchy.png">





  
  
  <link rel="canonical" href="javior.wang/2019/05/05/backends/spring/Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC | Javior's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Javior's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/index.html" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="javior.wang/2019/05/05/backends/spring/Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Javior Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Javior's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring文档笔记(三) Spring Framework Documentation - Web Servlet - Spring Web MVC

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-05 16:14:40" itemprop="dateCreated datePublished" datetime="2019-05-05T16:14:40+08:00">2019-05-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-15 13:23:20" itemprop="dateModified" datetime="2019-05-15T13:23:20+08:00">2019-05-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">Spring Framework Github</a><br><a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web.html#spring-web" target="_blank" rel="noopener">Spring Framework Documentation : Web Servlet - Version 5.1.6.RELEASE</a></p>
<h2 id="Ⅰ-Spring-Web-MVC"><a href="#Ⅰ-Spring-Web-MVC" class="headerlink" title="Ⅰ. Spring Web MVC"></a>Ⅰ. Spring Web MVC</h2><p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。其正式名称<code>Spring Web MVC</code>来自它的源模块(<code>spring-webmvc</code>)的名称，通常称为<code>Spring MVC</code>。<br>与Spring Web MVC并行，Spring Framework 5.0引入了一个reactive-stack Web框架，其名称<code>Spring WebFlux</code>也基于其源模块(<code>spring-webflux</code>)。[Spring WebFlux参见此处(<a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web-reactive.html#spring-webflux)。" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web-reactive.html#spring-webflux)。</a>   </p>
<h3 id="1-DispatcherServlet"><a href="#1-DispatcherServlet" class="headerlink" title="1. DispatcherServlet"></a>1. DispatcherServlet</h3><p>和很多其他web框架一样，Spring MVC也是围绕前端控制器模式设计的，其中一个中央Servlet————<code>DispatcherServlet</code>提供了一个共享的用于处理请求的算法，而实际工作是委派给可配置的组件(components)执行的。这种模型比较灵活，可以支持多种工作流(workflow)。<br>和所有的<code>servlet</code>一样，<code>DispatcherServlet</code>也需要根据Java Configuration或<code>web.xml</code>中的Servlet配置来声明和映射。然后，<code>DispatcherServlet</code>使用Spring配置来发现请求映射、视图解析、异常处理等所需的委托组件。<br>下面的例子演示了使用Java配置注册和初始化<code>DispatcherServlet</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletCxt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load Spring web application configuration</span></span><br><span class="line">        AnnotationConfigWebApplicationContext ac = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        ac.register(AppConfig.class);</span><br><span class="line">        ac.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and register the DispatcherServlet</span></span><br><span class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="string">"app"</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/app/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要直接使用ServletContext API，可以继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>类并覆写特定的方法。  </p>
</blockquote>
<p>下面是xml配置注册和初始化<code>DispatcherServlet</code>的例子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Spring Boot遵循不同的初始化顺序。Spring Boot没有连接到Servlet容器的生命周期中，而是使用Spring配置引导自身和嵌入的Servlet容器。在Spring配置中检测<code>Filter</code>和<code>Servlet</code>声明，并在Servlet容器中注册。详细信息见<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container" target="_blank" rel="noopener">Spring Boot documentation</a></p>
</blockquote>
<h4 id="1-1-Context-Hierarchy"><a href="#1-1-Context-Hierarchy" class="headerlink" title="1.1 Context Hierarchy"></a>1.1 Context Hierarchy</h4><p><code>DispatcherServlet</code>需要一个<code>WebApplicationContext</code>(<code>ApplicationContext</code>的扩展)来进行自己的配置。<code>WebApplicationContext</code>有一个指向<code>ServletContext</code>及与其关联的<code>Servlet</code>的链接。它还绑定到<code>ServletContext</code>，以便应用程序可以使用<code>RequestContextUtils</code>的静态方法来查找需要访问的<code>WebApplicationContext</code>。<br>对许多应用来说，一个<code>WebApplicationContext</code>已经足够了。同时也允许有一个context hierarchy，不止一个<code>DispatcherServlet</code>(或其他<code>Servlet</code>)实例共享一个root <code>WebApplicationContext</code>，每个实例有自己的子<code>WebApplicationContext</code>配置。<br>root <code>WebApplicationContext</code>通常包含基础设置bean，如data repositories和business services。这些bean可以有效地继承，并且可以在特定于Servlet的子<code>WebApplicationContext</code>中重写(即重新声明)，子<code>WebApplicationContext</code>通常包含特定Servlet的本地bean。它们的关系如下图：</p>
<div align="center"><br>      <img src="/images/backend/spring/springframework/03-01-mvc-context-hierarchy.png" width="500" height="500"><br></div>

<p>下例配置了一个<code>WebApplicationContext</code>层级：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/app1/*"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不需要使用应用上下文层次结构，则应用程序的<code>getRootConfigClasses()</code>会返回所有的配置，以及<code>getServletConfigClasses()</code>返回<code>null</code>。  </p>
</blockquote>
<p>下面是用<code>web.xml</code>配置的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不需要应用上下文层次结构，应用程序可能只配置一个”root”上下文，且将<code>contextConfigLocation</code>留空。  </p>
</blockquote>
<h4 id="1-2-Special-Bean-Types"><a href="#1-2-Special-Bean-Types" class="headerlink" title="1.2 Special Bean Types"></a>1.2 Special Bean Types</h4><p><code>DispatcherServlet</code>委托特殊的bean来处理请求并呈现适当的响应。这里所谓的特殊bean是指实现框架合约的Spring管理的对象实例。这通常是框架内置的，但是也可以自定义属性、扩展或替换它们。<br>下表列出了<code>DispatcherServlet</code>探测的特殊bean：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Bean type</th>
<th style="text-align:left">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HandlerMapping</td>
<td style="text-align:left">将请求连同预处理和后处理的拦截器列表映射到handler。映射基于一些标准，标准的细节因<code>HandlerMapping</code>具体实现类而异。<br>两个主要的<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code>(支持<code>@RequestMapping</code>注解)和<code>SimpleUrlHandlerMapping</code>(维护URI路径到handler的显式注册)。</td>
</tr>
<tr>
<td style="text-align:center">HandlerAdapter</td>
<td style="text-align:left">帮助<code>DispatcherServlet</code>调用与请求映射的handler，无论该handler实际是怎么调用的。例如，调用带注解的controller需要解析注解。<code>HandlerAdapter</code>的主要目的是保护<code>DispatcherServlet</code>不受此类细节的影响。</td>
</tr>
<tr>
<td style="text-align:center"><code>HandlerExceptionResolver</code></td>
<td style="text-align:left">解析异常的策略，可能将异常映射到handler、HTML error视图或其他目标。</td>
</tr>
<tr>
<td style="text-align:center">ViewResolver</td>
<td style="text-align:left">将从handler返回的基于String的视图名字解析到实际的<code>View</code>，以呈现给response。</td>
</tr>
<tr>
<td style="text-align:center"><code>LocaleResolver</code>,LocaleContextResolver</td>
<td style="text-align:left">解析客户端正在使用的<code>Locale</code>和时区，以提供国际化的视图。</td>
</tr>
<tr>
<td style="text-align:center">ThemeResolver</td>
<td style="text-align:left">解析web程序可以使用的主题，如提供个性化布局。</td>
</tr>
<tr>
<td style="text-align:center"><code>MultipartResolver</code></td>
<td style="text-align:left">使用一些multipart解析库来解析multi-part请求(如文件上传表单)的抽象。</td>
</tr>
<tr>
<td style="text-align:center">FlashMapManger</td>
<td style="text-align:left">存储和检索input和output<code>FlashMap</code>，它们可用于将属性从一个请求传递给另一个请求，通常是通过重定向。</td>
</tr>
</tbody>
</table>
<h4 id="1-3-Web-MVC-Config"><a href="#1-3-Web-MVC-Config" class="headerlink" title="1.3 Web MVC Config"></a>1.3 Web MVC Config</h4><p>应用程序可以声明上一小节列出的用来处理请求的基础设施bean。<code>DispatcherServlet</code>在<code>WebApplicationContext</code>中检查每种特殊bean，如果没有匹配的bean类型，它就会以来<code>DispatcherServlet.properties</code>中列出的默认类型。<br>In most cases, the MVC Config is the best starting point. It declares the required beans in either Java or XML and provides a higher-level configuration callback API to customize it.  </p>
<blockquote>
<p>Spring Boot以来MVC Java配置来配置Spring MVC并提供了很多额外的便利的选项。</p>
</blockquote>
<h4 id="1-4-Servlet-Config"><a href="#1-4-Servlet-Config" class="headerlink" title="1.4 Servlet Config"></a>1.4 Servlet Config</h4><p>在Servlet 3.0+环境下，可以选择以编程方式配置Servlet容器，或者与<code>web.xml</code>组合使用。下面的配置注册了一个<code>DispatcherServlet</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic registration = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>WebApplicationInitializer</code>是Spring MVC提供的接口，这个接口的实现类可以被自动探测并用来初始化任意的Servlet 3容器。抽象类<code>AbstractDispatcherServletInitializer</code>继承了这个接口，并覆写了方法来指明servlet映射和<code>DispatcherServlet</code>配置的位置，这样注册<code>DispatcherServlet</code>更加容易。<br>建议使用Java-based Spring configuration，如下例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果使用xml配置，需要直接继承<code>AbstractDispatcherServletInitializer</code>，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        XmlWebApplicationContext cxt = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AbstractDispatcherServletInitializer</code>也提供了一个简便方法来添加<code>Filter</code>实例并将它们自动映射到<code>DispatcherServlet</code>，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123;</span><br><span class="line">            <span class="keyword">new</span> HiddenHttpMethodFilter(), <span class="keyword">new</span> CharacterEncodingFilter() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个filter都根据其具体类型添加一个默认名称，并自动映射到<code>DispatcherServlet</code>。<br><code>AbstractDispatcherServletInitializer</code>的<code>isAsyncSupported</code> protected 方法提供了一个标志位来在<code>DispatcherServlet</code>和所有映射到<code>DispatcherServlet</code>的filters上启用异步支持。默认情况下，标志设置为<code>true</code>。<br>最后，如果需要更进一步自定义<code>DispatcherServlet</code>，可以覆写<code>createDispatcherServlet</code>方法。  </p>
<h4 id="1-5-Processing"><a href="#1-5-Processing" class="headerlink" title="1.5 Processing"></a>1.5 Processing</h4><p><code>DispatcherServlet</code>如下处理请求：</p>
<ul>
<li>The <code>WebApplicationContext</code> is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key.</li>
<li>The locale resolver is bound to the request to let elements in the process resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need the locale resolver.</li>
<li>The theme resolver is bound to the request to let elements such as views determine which theme to use. If you do not use themes, you can ignore it.</li>
<li>If you specify a multipart file resolver, the request is inspected for multiparts. If multiparts are found, the request is wrapped in a <code>MultipartHttpServletRequest</code> for further processing by other elements in the process.</li>
<li>An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering. Alternatively, for annotated controllers, the response can be rendered (within the HandlerAdapter) instead of returning a view.</li>
<li>If a model is returned, the view is rendered. If no model is returned (maybe due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled.</li>
</ul>
<p><code>WebApplicationContext</code>中声明的<code>HandlerExceptionResolver</code>bean用来解析请求处理流程中的异常。这些异常解析器允许定制处理异常的逻辑。<br>Spring <code>DispatcherServlet</code>也支持返回Servlet API指定的<code>last-modification-data</code>。确定请求的最后修改日期的过程很简单：<code>DispatcherServlet</code>查找一个适当的handler mapping并测试找到的handler是够实现了<code>LastModified</code>接口。如果实现了，那么<code>LastModified</code>接口的<code>long getLastModified(request)</code>方法的值就返回给客户端。<br>可以通过向<code>web.xml</code>中的Servlet声明添加Servlet初始化参数(<code>init-param</code>元素)自定义独立的<code>DispatcherServlet</code>实例。下表列出了支持的参数：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Patameter</th>
<th style="text-align:center">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">contextClass</td>
<td style="text-align:center">Class that implements <code>ConfigurableWebApplicationContext</code>, to be instantiated and locally configured by this Servlet. By default, <code>XmlWebApplicationContext</code> is used.</td>
</tr>
<tr>
<td style="text-align:center">contextConfigLocation</td>
<td style="text-align:center">String that is passed to the context instance (specified by <code>contextClass</code>) to indicate where contexts can be found. The string consists potentially of multiple strings (using a comma as a delimiter) to support multiple contexts. In the case of multiple context locations with beans that are defined twice, the latest location takes precedence.</td>
</tr>
<tr>
<td style="text-align:center">namespace</td>
<td style="text-align:center">Namespace of the <code>WebApplicationContext</code>. Defaults to <code>[servlet-name]-servlet</code>.</td>
</tr>
<tr>
<td style="text-align:center">throwExceptionIfNoHandlerFound</td>
<td style="text-align:center">Whether to throw a <code>NoHandlerFoundException</code> when no handler was found for a request. The exception can then be caught with a <code>HandlerExceptionResolver</code> (for example, by using an <code>@ExceptionHandler</code> controller method) and handled as any others. <br> By default, this is set to <code>false</code>, in which case the <code>DispatcherServlet</code> sets the response status to 404 (NOT_FOUND) without raising an exception. <br> Note that, if default servlet handling is also configured, unresolved requests are always forwarded to the default servlet and a 404 is never raised.</td>
</tr>
</tbody>
</table>
<h4 id="1-6-Interception"><a href="#1-6-Interception" class="headerlink" title="1.6 Interception"></a>1.6 Interception</h4><p>所有的<code>HandlerMapping</code>实现都支持interceptor(拦截器)，当希望特定功能应用于特定请求时这些拦截器非常有用。拦截器必须实现<code>org.springframework.web.servlet</code>包<code>HandlerInterceptor</code>接口的三个方法，以提供足够的灵活性来应付所有的预处理和后处理：</p>
<ul>
<li><code>preHandle(..)</code>: 在实际的handler执行之前</li>
<li><code>postHandle(..)</code>: 在handler执行之后</li>
<li><code>afterCompletion(..)</code>: 在整个请求结束后</li>
</ul>
<p><code>preHandle(..)</code>方法返回一个布尔类型。可以使用这个方法来break或continue执行链的过程。当方法返回<code>true</code>时，handler execution chain continues。当返回<code>false</code>，<code>DispatcherServlet</code>则假设拦截器本身已经处理了请求(如返回一个视图)，并且不再继续执行其他拦截器和执行链中的handler。<br>拦截器配置见MVC configuration中的Interceptors小节。也可以在<code>HandlerMapping</code>实现中使用setters直接注册拦截器。<br>注意<code>postHandle</code>对于<code>@ResponseBody</code>和<code>@ResponseEntity</code>注解的方法不太实用，这些方法的响应在<code>HandlerAdapter</code>和<code>postHandle</code>之前写入和提交。这也就意味着此时对响应做出改变已经太晚了。这种场景可以实现<code>ResponseBodyAdvice</code>并将其生命为Controller Advice bean或在<code>RequestMappingHandlerAdapter</code>中直接配置。  </p>
<h4 id="1-7-Exceptions"><a href="#1-7-Exceptions" class="headerlink" title="1.7 Exceptions"></a>1.7 Exceptions</h4><p>如果在请求映射过程中发生了异常或从请求handler(如<code>@controller</code>)中抛出了异常，<code>DispatcherServlet</code>委派a chain of <code>HandlerExceptionResolver</code>beans 来解析异常并提供替代处理(通常是一个error response)。<br>下表列出了可选的<code>HandlerExceptionResolver</code>实现：</p>
<table>
<thead>
<tr>
<th style="text-align:center">HandlerExceptionResolver</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SimpleMappingExceptionResolver</td>
<td style="text-align:center">A mapping between exception class names and error view names. Useful for rendering error pages in a browser application.</td>
</tr>
<tr>
<td style="text-align:center">DefaultHandlerExceptionResolver</td>
<td style="text-align:center">Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. See also alternative <code>ResponseEntityExceptionHandler</code> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-rest-exceptions" target="_blank" rel="noopener">REST API exceptions</a>.</td>
</tr>
<tr>
<td style="text-align:center">ResponseStatusExceptionResolver</td>
<td style="text-align:center">Resolves exceptions with the <code>@ResponseStatus</code> annotation and maps them to HTTP status codes based on the value in the annotation.</td>
</tr>
<tr>
<td style="text-align:center">ExceptionHandlerExceptionResolver</td>
<td style="text-align:center">Resolves exceptions by invoking an <code>@ExceptionHandler</code> method in a <code>@Controller</code> or a <code>@ControllerAdvice</code> class.</td>
</tr>
</tbody>
</table>
<h5 id="A-Chain-of-Resolvers"><a href="#A-Chain-of-Resolvers" class="headerlink" title="A. Chain of Resolvers"></a>A. Chain of Resolvers</h5><p>通过在Spring配置中声明多个<code>HandlerExceptionResolver</code>bean并根据需要设置它们的<code>order</code>属性，可以塑造一个异常解析器链。<code>order</code>属性越大，异常解析器执行的就越晚。<br><code>HandlerExceptionResolver</code>可以返回的值有：</p>
<ul>
<li>a <code>ModelAndView</code> that points to an error view.</li>
<li>An empty <code>ModelAndView</code> if the exception was handled within the resolver.</li>
<li><code>null</code> if the exception remains unresolved, for subsequent resolvers to try, and, if the exception remains at the end, it is allowed to bubble up to the Servlet container.</li>
</ul>
<p>MVC Config声明了内置的解析器列表，用于Spring MVC异常、<code>@ResponseStatus</code>注解的异常和<code>@ExceptionHandler</code>注解的方法的默认处理。可以自定义这个list或者替换它。  </p>
<h5 id="B-Container-Error-Page"><a href="#B-Container-Error-Page" class="headerlink" title="B. Container Error Page"></a>B. Container Error Page</h5><p>如果任何<code>HandlerExceptionResolver</code>仍然无法解析异常，这时需要传播异常，或者如果响应状态设置为错误状态(即4xx、5xx)， Servlet容器可以呈现一个默认的错误HTML页面。自定义容器的error page，可以在<code>web.xml</code>中声明一个错误页面映射。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当出现异常或相应有错误状态时，Servlet容器在容器内将ERROR分派到配置的URL(如<code>/error</code>)。然后由<code>DispatcherServlet</code>处理，可能将其映射到一个<code>@Controller</code>，该<code>@Controller</code>可以返回一个Model and View或呈现JSON响应，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/error"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">handle</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"status"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</span><br><span class="line">        map.put(<span class="string">"reason"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
</blockquote>
<p>The Servlet API does not provide a way to create error page mappings in Java. You can, however, use both a <code>WebApplicationInitializer</code> and a minimal <code>web.xml</code>.</p>
<h4 id="1-8-View-Resolution"><a href="#1-8-View-Resolution" class="headerlink" title="1.8 View Resolution"></a>1.8 View Resolution</h4><p>Spring MVC定义了<code>ViewResolver</code>和<code>View</code>接口来在浏览器中呈现model。<code>ViewResolver</code>提供了视图名到实际视图之间的映射，<code>View</code>处理移交给一个特定视图技术之前的数据准备工作。<br>下表列出了<code>ViewResolver</code>层次结构的更多细节：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ViewResolver</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AbstractCachingViewResolver</td>
<td style="text-align:left"><code>AbstractCachingViewResolver</code>的子类缓存它们解析的视图实例。缓存提高了某些视图技术的性能。可以通过将<code>cache</code>属性设置为<code>false</code>来关闭缓存。此外，如果必须在运行时刷新某个视图(例如，修改FreeMarker模板时)，可以使用<code>removeFromCache(String viewName, Locale loc)</code>方法。</td>
</tr>
<tr>
<td style="text-align:center">XmlViewResolver</td>
<td style="text-align:left"><code>ViewResolver</code>的实现，它接受使用与Spring的XML bean工厂相同DTD的XML编写的配置文件。默认配置文件是<code>/WEB-INF/views.xml</code>。</td>
</tr>
<tr>
<td style="text-align:center">ResourceBundleViewResolver</td>
<td style="text-align:left"><code>ViewResolver</code>的实现，它使用<code>ResourceBundle</code>中的bean定义，<code>ResourceBundle</code>对应特定的bundle base name。对于应该解析的每个视图，它使用<code>[viewname].(class)</code>属性的值作为视图类，并使用<code>[viewname].url</code>属性的值作为视图url。</td>
</tr>
<tr>
<td style="text-align:center">UrlBasedViewResolver</td>
<td style="text-align:left"><code>ViewResolver</code>接口的简单实现.在没有显式映射定义的情况下,该接口影响逻辑视图名称到URL的直接解析。如果逻辑名称以一种直接的方式匹配视图资源的名称，而不需要任意映射，那么这是合适的。</td>
</tr>
<tr>
<td style="text-align:center">InternalResourceViewResolver</td>
<td style="text-align:left"><code>UrlBasedViewResolver</code>的子类，它支持<code>InternalResourceView</code>(实际上是Servlet和jsp)和<code>JstlView</code>和<code>TilesView</code>等的子类。可以使用<code>setViewClass(..)</code>为这个解析器生成的所有视图指定视图类。</td>
</tr>
<tr>
<td style="text-align:center">FreeMarkerViewResolver</td>
<td style="text-align:left">方便的<code>UrlBasedViewResolver</code>子类，支持<code>FreeMarkerView</code>和它们的自定义子类。</td>
</tr>
<tr>
<td style="text-align:center">ContentNegotiatingViewResolver</td>
<td style="text-align:left"><code>ViewResolver</code>接口的实现，该接口根据请求文件名或<code>Accept</code>头解析视图。</td>
</tr>
</tbody>
</table>
<h5 id="A-Handling"><a href="#A-Handling" class="headerlink" title="A. Handling"></a>A. Handling</h5><p>可以声明不止一个视图解析器，此时可以使用<code>order</code>属性来指定顺序。<code>order</code>属性值越大，视图解析器链中视图解析器就顺位就越低。<br><code>ViewResolver</code>的合约指定它可以返回<code>null</code>来表示找不到视图。然而，对于JSP和<code>InternalResourceViewResolver</code>，判断JSP是否存在的唯一方法是通过<code>RequestDispatcher</code>执行分派。因此，必须始终配置一个<code>InternalResourceViewResolver</code>，使其在视图解析器的整体顺序中位于最后。<br>MVC配置为视图解析器和添加无逻辑视图控制器提供了专用的配置API，这对于没有控制器逻辑的HTML模板呈现非常有用。</p>
<h5 id="B-Redirecting"><a href="#B-Redirecting" class="headerlink" title="B. Redirecting"></a>B. Redirecting</h5><p>视图名的<code>redirect:</code>前缀允许执行重定向。<code>UrlBasedViewResolver</code>以及它的子类将这个前缀看成是重定向的指令。其余的视图名部分是重定向的URL。<br>最终效果与控制器(<code>@Controller</code>)返回<code>RedirectView</code>相同，但现在控制器本身可以根据逻辑视图名进行操作。逻辑视图名(如<code>redirect:/myapp/some/resource</code>)相对于当前Servlet上下文重定向，而名称(如<code>redirect: https://myhost.com/some/arbitrary/path</code>)重定向到绝对URL。<br>需要注意的是，如果一个控制器被<code>@ResponseStatus</code>注解，注解值优先于<code>RedirectView</code>设置的响应状态。  </p>
<h5 id="C-Forwarding"><a href="#C-Forwarding" class="headerlink" title="C. Forwarding"></a>C. Forwarding</h5><p>带<code>forward:</code>前缀的视图名最终会被<code>UrlBasedViewResolver</code>和它的子类解析。这将创建一个<code>InternalResourceView</code>,<code>InternalResourceView</code>执行<code>RequestDispatcher.forward()</code>。因此这个前缀对于<code>InternalResourceViewResolver</code>和<code>InternalResourceView</code>(JSPs)是没用的，但如果使用其他视图技术而且希望由Servlet/JSP引擎来处理资源的forward，这就是有用的。注意也可以组成有多个资源解析器的链。</p>
<h5 id="D-Content-Negotiation"><a href="#D-Content-Negotiation" class="headerlink" title="D. Content Negotiation"></a>D. Content Negotiation</h5><p><code>ContentNegotiatingViewResolver</code>并不解析视图，而是委派给其他视图解析器并且选择与客户端请求的表示形式类似的视图。这可以由<code>Accept</code> header或查询参数(如，<code>/path?format=pdf</code>)决定。<br><code>ContentNegotiatingViewResolver</code>通过将请求的媒体类型与每个<code>ViewResolver</code>关联的视图支持的媒体类型(<code>Content-Type</code>)进行比较，选择适当的视图来处理请求。列表中兼容<code>Content-Type</code>的第一个视图将表示返回给客户端。如果视图解析器链中没有合适的视图，将查询通过<code>DefaultViews</code>属性指定的视图列表。后一个选项适用于单例视图，它可以呈现当前资源的适当的表示，无论逻辑视图名称是什么。<code>Accept</code>头可以包含通配符(例如<code>text/*</code>)，在这种情况下，<code>Content-Type</code>为<code>text/xml</code>的视图是兼容的匹配。  </p>
<h4 id="1-9-Locale"><a href="#1-9-Locale" class="headerlink" title="1.9 Locale"></a>1.9 Locale</h4><p>如同Spring架构的大部分都支持国际化一样，Spring web MVC也支持国际化。<code>DispatcherServlet</code>可以根据客户端的locale自动解析信息。这是通过<code>LocaleResolver</code>对象来实现的。<br>当一个请求到达时，<code>DispatcherServlet</code>查找一个locale(区域设置)解析器，如果找到，就使用这个解析器来设置locale。通过使用<code>RequestContext.getLocale()</code>方法，始终可以检索由locale解析器解析的locale。<br>除了自动解析locale之外，可以将拦截器添加到处理程序映射中，以在特定环境下更改区域设置(例如，基于请求中的参数)。<br>locale解析器和拦截器在<code>org.springframework.web.servlet.i18n</code>中定义，并在应用程序上下文中以普通方式配置。Spring中包含以下locale解析器：</p>
<ul>
<li>Time Zone</li>
<li>Header Resolver</li>
<li>Cookie Resolver</li>
<li>Session Resolver</li>
<li>Locale Interceptor</li>
</ul>
<h5 id="A-Time-Zone"><a href="#A-Time-Zone" class="headerlink" title="A. Time Zone"></a>A. Time Zone</h5><p>除了获得客户端的地区之外，了解它的时区也很有用。<code>LocaleContextResolver</code>接口提供了<code>LocaleResolver</code>的扩展，可以让解析器提供更丰富的<code>LocaleContext</code>，其中可能会包含时区信息。<br>如果包含时区信息，可以使用<code>RequestContext.getTimeZone()</code>方法获得用户的时区。任何在Spring的<code>ConversionService</code>中注册的日期/时间<code>Converter</code>和<code>Formatter</code>对象都会自动使用时区信息。  </p>
<h5 id="B-Header-Resolver"><a href="#B-Header-Resolver" class="headerlink" title="B. Header Resolver"></a>B. Header Resolver</h5><p>此locale解析器检查客户端(如web浏览器)发送的请求中的<code>accept-language</code>头。通常，这个头字段包含客户机操作系统的locale。注意，此解析器不支持时区信息。</p>
<h5 id="C-Cookie-Resolver"><a href="#C-Cookie-Resolver" class="headerlink" title="C. Cookie Resolver"></a>C. Cookie Resolver</h5><p>此locale解析器检查客户机上可能存在的<code>Cookie</code>，以查看是否指定了<code>Locale</code>或<code>TimeZone</code>。如果是，则使用指定的详细信息。通过使用这个locale解析器的属性，您可以指定cookie的名称以及maximum age。下面的示例定义了一个<code>CookieLocaleResolver</code> :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"clientlanguage"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieMaxAge"</span> <span class="attr">value</span>=<span class="string">"100000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下表列出了<code>CookieLocaleResolver</code>的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Property</th>
<th style="text-align:center">Default</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cookieName</td>
<td style="text-align:center">classname + LOCALE</td>
<td style="text-align:left">cookie名</td>
</tr>
<tr>
<td style="text-align:center">cookieMaxAge</td>
<td style="text-align:center">Servlet container default</td>
<td style="text-align:left">cookie在客户端上保存的最长时间。如果指定-1,cookie将不会被持久化，它只在客户端关闭浏览器之前可用。</td>
</tr>
<tr>
<td style="text-align:center">cookiePath</td>
<td style="text-align:center">/</td>
<td style="text-align:left">将cookie的可见性限制在网站的特定部分。当指定<code>cookiePath</code>时，cookie仅对该路径及其子路径可见。</td>
</tr>
</tbody>
</table>
<h5 id="D-Session-Resolver"><a href="#D-Session-Resolver" class="headerlink" title="D. Session Resolver"></a>D. Session Resolver</h5><p><code>SessionLocaleResolver</code>可以从可能与用户请求关联的会话中检索<code>Locale</code>和<code>TimeZone</code>。与<code>CookieLocaleResolver</code>相反，该策略将本地选择的locale设置存储在Servlet容器的<code>HttpSession</code>中。因此，这些设置对于每个会话都是临时的，当每个会话终止时这些设置就会丢失。<br>注意，它与外部会话管理机制(如Spring Session project)没有直接关系。这个<code>SessionLocaleResolver</code>根据当前<code>HttpServletRequest</code>计算和修改相应的<code>HttpSession</code>属性。  </p>
<h5 id="E-Locale-Interceptor"><a href="#E-Locale-Interceptor" class="headerlink" title="E. Locale Interceptor"></a>E. Locale Interceptor</h5><p>您可以通过将<code>LocaleChangeInterceptor</code>添加到<code>HandlerMapping</code>定义中来启用更改locale。它检测请求中的参数并相应地更改locale设置，在dispatcher的应用程序上下文中调用<code>LocaleResolver</code>上的<code>setLocale</code>方法。下例显示调用所有的包含<code>siteLanguage</code>参数的<code>*.view</code>资源将更改区域设置。例如，一个URL请求<code>https://www.sf.net/home.view?siteLanguage=nl</code>，将站点语言更改为荷兰语。下面的例子演示了如何拦截区域设置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeChangeInterceptor"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"paramName"</span> <span class="attr">value</span>=<span class="string">"siteLanguage"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"urlMapping"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"localeChangeInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/**/*.view=someController<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1-10-Themes"><a href="#1-10-Themes" class="headerlink" title="1.10 Themes"></a>1.10 Themes</h4><p>您可以应用Spring Web MVC框架主题来设置应用程序的整体外观，从而增强用户体验。主题是一组静态资源，通常是style sheets和图片，它们影响应用程序的视觉样式。</p>
<h5 id="A-Defining-a-theme"><a href="#A-Defining-a-theme" class="headerlink" title="A. Defining a theme"></a>A. Defining a theme</h5><p>要在web应用程序中使用主题，必须完成<code>org.springframework.ui.context.ThemeSource</code>的实现。<code>WebApplicationContext</code>接口扩展了<code>ThemeSource</code>，但将其职责委托给专用的实现类。默认情况下，委托是<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>实现，它从类路径的根加载属性文件。要使用自定义<code>ThemeSource</code>实现或配置<code>ResourceBundleThemeSource</code>的base name prefix，可以使用保留的名称<code>themeSource</code>在应用程序上下文中注册bean。web应用程序上下文自动检测具有该名称的bean并使用它。<br>当使用<code>ResourceBundleThemeSource</code>时，主体是在属性文件中定义的。属性文件列出组成主体的资源，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">styleSheet=/themes/cool/style.css</span><br><span class="line">background=/themes/cool/img/coolBg.jpg</span><br></pre></td></tr></table></figure></p>
<p>属性文件中的key是视图代码中与主题相关的元素。对于JSP来说，通常是使用<code>spring:theme</code>标签，这和<code>spring:message</code>很像。下面的JSP片段使用前面例子中定义的主题来定制外观:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"spring"</span> <span class="attr">uri</span>=<span class="string">"http://www.springframework.org/tags"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"&lt;spring:theme code='styleSheet'/&gt;"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background=&lt;spring:theme code='background'/&gt;"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，<code>ResourceBundleThemeSource</code>使用空的base name prefix。因此，属性文件是从类路径的根目录加载的。这样就要将<code>cool.properties</code>主题定义文件放在类路径根目录中(例如<code>/WEB-INF/classes</code>)。<code>ResourceBundleThemeSource</code>使用标准的Java资源包加载机制，允许主题的完全国际化。例如，我们可以有<code>/WEB-INF/classes/cool_nl.properties</code>来引用具有荷兰语文本的特殊背景图像。  </p>
<h5 id="B-Resolving-Themes"><a href="#B-Resolving-Themes" class="headerlink" title="B. Resolving Themes"></a>B. Resolving Themes</h5><p>在定义了主题之后(如上节所述)，就可以决定使用哪个主题。<code>DispatcherServlet</code>查找一个名为<code>themeResolver</code>的bean，以确定使用哪个<code>ThemeResolver</code>实现。主题解析器的工作方式与<code>LocaleResolver</code>非常相似。它检测用于特定请求的主题，还可以更改请求的主题。下表描述了Spring提供的主题解析器:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Class</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FixedThemeResolver</td>
<td style="text-align:left">选择使用<code>defaultThemeName</code>属性设置的固定主题。</td>
</tr>
<tr>
<td style="text-align:center">SessionThemeResolver</td>
<td style="text-align:left">主题在用户的HTTP session中维护。它只需要为每个会话设置一次，而不需要在会话间持久化主题。</td>
</tr>
<tr>
<td style="text-align:center">CookieThemeResolver</td>
<td style="text-align:left">所选主题存储在客户机上的cookie中。</td>
</tr>
</tbody>
</table>
<h4 id="1-11-Multipart-Resolver"><a href="#1-11-Multipart-Resolver" class="headerlink" title="1.11  Multipart Resolver"></a>1.11  Multipart Resolver</h4><p><code>org.springframework.web.multipart</code>包的<code>MultipartResolver</code>是一种解析包括文件上传在内的多部件请求(multipart requests)的策略。有一种基于<a href="http://commons.apache.org/proper/commons-fileupload/" target="_blank" rel="noopener">Commons FileUpload</a>的实现和基于Servlet 3.0多部件请求解析的实现。<br>要启用多部件处理，需要在<code>DispatcherServlet</code>Spring配置中声明一个<code>MultipartResolver</code>bean。<code>DispatcherServlet</code>检测它并将其应用于传入的请求。当接收到具有<code>multipart/form-data</code>的content-type的<code>POST</code>时，解析器解析内容并将当前<code>HttpServletRequest</code>包装为<code>MultipartHttpServletRequest</code>，以便提供对已解析部分的访问，并将其公开为请求参数。  </p>
<h5 id="A-Apache-Commons-FileUpload"><a href="#A-Apache-Commons-FileUpload" class="headerlink" title="A. Apache Commons FileUpload"></a>A. Apache Commons <code>FileUpload</code></h5><p>To use Apache Commons <code>FileUpload</code>, you can configure a bean of type <code>CommonsMultipartResolver</code> with a name of <code>multipartResolver</code>. You also need to have <code>commons-fileupload</code> as a dependency on your classpath.  </p>
<h5 id="B-Servlet-3-0"><a href="#B-Servlet-3-0" class="headerlink" title="B. Servlet 3.0"></a>B. Servlet 3.0</h5><p>Servlet 3.0需要通过Servlet容器配置启用多部件解析。配置的方式有：</p>
<ul>
<li>In Java, set a <code>MultipartConfigElement</code> on the Servlet registration.</li>
<li>In <code>web.xml</code>, add a <code>&quot;&lt;multipart-config&gt;&quot;</code> section to the servlet declaration.  </li>
</ul>
<p>下例展示了如何在Servlet registration设置<code>MultipartConfigElement</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span></span><br><span class="line">        registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦Servlet 3.0配置就绪，您就可以添加一个名为<code>multipartResolver</code>、类型为<code>StandardServletMultipartResolver</code>的bean。  </p>
<h4 id="1-12-Logging"><a href="#1-12-Logging" class="headerlink" title="1.12 Logging"></a>1.12 Logging</h4><p>Spring MVC中的DEBUG级日志记录被设计为紧凑、最小且人性化。它着重于可复用的高价值信息，而不是只在调试特定问题时有用的信息。<br>TRACE级日志通常遵循与DEBUG相同的原则，但是可以用于调试任何问题。此外，相较于DEBUG，一些日志消息在TRACE时可能显示一个不同级别的详细信息。   </p>
<h5 id="A-Sensitive-Data"><a href="#A-Sensitive-Data" class="headerlink" title="A. Sensitive Data"></a>A. Sensitive Data</h5><p>DEBUG和TRACE日志可能会记录敏感信息。这就是为什么请求参数和头在缺省情况下被屏蔽，并且必须通过<code>DispatcherServlet</code>上的<code>enableLoggingRequestDetails</code>属性显式地启用完整记录。<br>下例演示了怎么启用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInitializer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(Dynamic registration)</span> </span>&#123;</span><br><span class="line">        registration.setInitParameter(<span class="string">"enableLoggingRequestDetails"</span>, <span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Filters"><a href="#2-Filters" class="headerlink" title="2. Filters"></a>2. Filters</h3><p><code>spring-web</code>模块提供了一些很有用的过滤器：</p>
<ul>
<li>Form Data</li>
<li>Forwarded Headers</li>
<li>Shallow ETag</li>
<li>CORS</li>
</ul>
<h4 id="2-1-Form-Data"><a href="#2-1-Form-Data" class="headerlink" title="2.1 Form Data"></a>2.1 Form Data</h4><p>浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户机也可以使用HTTP PUT、PATCH和DELETE。Servlet API要求<code>ServletRequest.getParameter*()</code>方法只支持HTTP POST的表单字段准入。<br><code>spring-web</code>模块提供<code>FormContentFilter</code>拦截content-type是<code>application/x-www-form-urlencoded</code>的HTTP PUT、PATCH、和DELETE请求,从body读取表单数据,并通过<code>ServletRequest.getParameter*()</code>方法包装<code>ServletRequest</code>来使表单数据可用。  </p>
<h4 id="2-2-Forwarded-Headers"><a href="#2-2-Forwarded-Headers" class="headerlink" title="2.2 Forwarded Headers"></a>2.2 Forwarded Headers</h4><p>当请求通过代理(例如负载平衡器)时，主机、端口和模式可能会发生更改，这使得从客户端角度创建指向正确主机、端口和模式的链接成为一项挑战。<br> <a href="https://tools.ietf.org/html/rfc7239" target="_blank" rel="noopener">RFC 7239</a>定义了<code>Forwarder</code> HTTP header，可以被代理用来提供源请求的信息。也有一些其他的非标准化的header，包括<code>X-Forwarded-Host</code>,<code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code>,和<code>X-Forwarded-Prefix</code>。<br> <code>ForwardHeaderFilter</code>是一个Servlet过滤器，它根据<code>Forwarded</code>头修改请求的主机、端口和方案，然后删除这些头。<br> 由于应用程序无法知道这些头是由代理添加的，还是由具有恶意的客户机添加的，所以转发头需要考虑安全性。这就是为什么应该将位于信任边界的代理配置为删除来自外部的不受信任的<code>Forwarded</code>头。还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderFilter</code>，在这种情况下，它删除但不使用头文件。  </p>
<h4 id="2-3-Shallow-ETag"><a href="#2-3-Shallow-ETag" class="headerlink" title="2.3 Shallow ETag"></a>2.3 Shallow ETag</h4><p><code>ShallowEtagHeaderFilter</code>过滤器通过缓存写入响应的内容并计算MD5来创建一个”shallow” ETag。下一次客户机发送内容时，它也会执行相同的操作，但是它还会将计算出的值与<code>If-None-Match</code>请求头进行比较，如果两者相等，则返回304 (NOT_MODIFIED)。<br>这种策略节省了网络带宽，但不节省CPU，因为必须为每个请求计算完整的响应。前面描述的控制器级的其他策略可以避免计算。<br>这个过滤器有一个<code>writeWeakETag</code>参数，该参数将过滤器配置为写weak ETags，类似于以下代码:<code>W/&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code>(as defined in <a href="https://tools.ietf.org/html/rfc7232#section-2.3" target="_blank" rel="noopener">RFC 7232 Section 2.3</a>)。</p>
<h5 id="2-4-CORS"><a href="#2-4-CORS" class="headerlink" title="2.4 CORS"></a>2.4 CORS</h5><p>Spring MVC通过控制器上的注释为CORS配置提供了细粒度支持。然而，当与Spring Security一起使用时，建议依赖于内置的<code>CorsFilter</code>，该<code>CorsFilter</code>的顺序必须在Spring Security的过滤器链之前。<br>具体参见下文。  </p>
<h3 id="3-Annotated-Controllers"><a href="#3-Annotated-Controllers" class="headerlink" title="3. Annotated Controllers"></a>3. Annotated Controllers</h3><p>Spring MVC提供了一个基于注解的编程模型，其中<code>@Controller</code>和<code>@RestController</code>组件使用注解来表示请求映射、请求输入、异常处理等等。带注解的控制器具有灵活的方法签名，不需要扩展基类或实现特定的接口。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>, <span class="string">"Hello World!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-Declaration"><a href="#3-1-Declaration" class="headerlink" title="3.1. Declaration"></a>3.1. Declaration</h4><p>可以通过在Servlet的<code>WebApplicationContext</code>中使用标准Spring bean定义来定义控制器bean。<code>@Controller</code>原型允许自动检测，与Spring在类路径中自动检测<code>@Component</code>类自动注册bean定义一致。它还充当带注解类的原型，指示其角色是作为web组件。<br>要启用自动检测<code>@Controller</code>bean，可以将组件扫描添加到Java配置中，如下面的示例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.example.web"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的XML配置是：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example.web"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>@RestController</code>是一个复合注解，它是由<code>@Controller</code>和<code>@ResponseBody</code>进行元注解的，以指示一个控制器的每个方法都继承类型级别的<code>@ResponseBody</code>注释，表示会直接将数据写入响应的body中，而不是使用HTML模板进行视图解析和呈现。  </p>
<h5 id="A-AOP-Proxies"><a href="#A-AOP-Proxies" class="headerlink" title="A. AOP Proxies"></a>A. AOP Proxies</h5><p>在某些情况下，可能需要在运行时用AOP代理来装饰控制器。比如，如果在控制器上直接使用<code>@Transactional</code>注释。这种情况建议使用基于类的代理。这通常是控制器的默认选择。然而，如果控制器必须实现一个不是Spring Context callback的接口(例如<code>InitializingBean</code>、<code>*Aware</code>等)，则可能需要显式地配置基于类的代理。比如使用<code>&lt;tx:annotation-driven/&gt;</code>可以更改为<code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code>。</p>
<h4 id="3-2-Request-Mapping"><a href="#3-2-Request-Mapping" class="headerlink" title="3.2 Request Mapping"></a>3.2 Request Mapping</h4><p>可以使用<code>@RequestMapping</code>注解将请求映射到控制器方法。它有各种属性，可以通过URL、HTTP方法、请求参数、头和媒体类型进行匹配。您可以在类级别使用它来表示共享的映射，或者在方法级使用它来缩小到特定的映射。<br>还有特定于HTTP方法的快捷方式变体<code>@RequestMapping</code>:</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>这些是提供的自定义注解，因为有种争论，即大多数控制器方法应该映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code>(默认情况下匹配所有HTTP方法)。与此同时，仍然需要在类级使用<code>@RequestMapping</code>来表示共享映射。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/persons"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="A-URI-patterns"><a href="#A-URI-patterns" class="headerlink" title="A. URI patterns"></a>A. URI patterns</h5><p>可以使用以下全局表达式和通配符来映射请求:</p>
<ul>
<li><code>?</code> matches one character</li>
<li><code>*</code> matches zero or more characters within a path segment</li>
<li><code>**</code> match zero or more path segments</li>
</ul>
<p>还可以声明URI变量并使用<code>@PathVariable</code>访问它们的值，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以声明类和方法不同级别的URI变量，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>URI变量会自动转换为适当的类型，或者引发<code>TypeMismatchException</code>。默认情况下支持简单类型(<code>int</code>、<code>long</code>、<code>Date</code>等)，也可以注册对任何其他数据类型的支持。<br>可以显式地命名URI变量(例如<code>@PathVariable(&quot;customId&quot;)</code>)，但是如果您的代码是使用调试信息编译的，或者Java 8上使用<code>-parameters</code>编译器标志编译的，且名称相同，则可以省略该细节。<br>语法<code>{varName:regex}</code>用一个正则表达式声明一个URI变量。例如，给定<code>URL&quot;/spring-web-3.0.5 .jar&quot;</code>，下面的方法提取名称、版本和文件扩展名:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@PathVariable String version, @PathVariable String ext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>URI路径模式还可以嵌入<code>${…}</code>占位符，这些占位符在启动时使用<code>PropertyPlaceHolderConfigurer</code>针对local变量、环境变量和其他变量进行解析。例如，可以使用它根据外部配置参数化基本URL。  </p>
<blockquote>
<p>Spring MVC uses the <code>PathMatcher</code> contract and the <code>AntPathMatcher</code> implementation from <code>spring-core</code> for URI path matching.  </p>
</blockquote>
<h5 id="B-Pattern-Comparison"><a href="#B-Pattern-Comparison" class="headerlink" title="B. Pattern Comparison"></a>B. Pattern Comparison</h5><p>当多个模式匹配一个URL时，必须对它们进行比较以找到最佳匹配。这是通过使用<code>AntPathMatcher.getPatternComparator(String path)</code>，它查找更具体的模式。<br>如果一个模式的URI变量数(计数为1)、单通配符数(计数为1)和双通配符数(计数为2)较低，那么该模式就不那么特定。给定相同的分数和长度，则选择URI变量多于通配符的模式。    当浏览器用于发送难以一致解释的Accept标头时，以这种方式使用文件扩展名是必要的。目前，这不再是必需的，使用Accept标头应该是首选。<br>默认的映射模式(<code>/**</code>)被排除在得分之外，并且总是排在最后。此外，前缀模式(如<code>/public/**</code>)被认为不如没有双通配符的其他模式具体。  </p>
<h5 id="C-Suffix-Match"><a href="#C-Suffix-Match" class="headerlink" title="C. Suffix Match"></a>C. Suffix Match</h5><p>默认情况下，Spring MVC执行<code>.*</code>后缀模式匹配，因此映射到<code>/person</code>的控制器也隐式映射到<code>/person.*</code>。然后，文件扩展名用于解释用于响应的请求内容类型(即，代替<code>Accept</code>头)——例如<code>/person.pdf</code>, <code>/person.xml</code>等。<br>当浏览器用于发送难以一致解释的<code>Accept</code>头时，以这种方式使用文件扩展名是必要的。现在这不再是必需的，使用<code>Accept</code>头应该是首选。<br>随着时间的推移，文件扩展名的使用在很多方面都存在问题。当重叠使用URI变量、路径参数和URI编码时，这可能会导致歧义。关于基于url的授权及安全性的推理也变得更加困难。<br>要完全禁用文件扩展名的使用，必须同时设置以下两项:</p>
<ul>
<li><code>useSuffixPatternMatching(false)</code></li>
<li><code>favorPathExtension(false)</code></li>
</ul>
<p>基于URL的内容协商仍然很有用(例如，在浏览器中输入URL时)。为了实现这一点，我们建议使用基于查询参数的策略来避免文件扩展所带来的大多数问题。另外，如果必须使用文件扩展名，可以考虑将它们限制在通过ContentNegotiationConfigurer的<code>mediaTypes</code>属性显式注册的扩展名列表。  </p>
<h5 id="D-Suffix-Match-and-RFD"><a href="#D-Suffix-Match-and-RFD" class="headerlink" title="D. Suffix Match and RFD"></a>D. Suffix Match and RFD</h5><p>反射文件下载(RFD, reflected file download)攻击类似于XSS，因为它依赖于请求输入(如查询参数和URI变量)反射到响应中。然而，RFD攻击不是将JavaScript插入HTML，而是依赖于浏览器切换来执行下载并在稍后双击时将响应视为可执行脚本。<br>在Spring MVC中，<code>@ResponseBody</code>和<code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展请求不同的内容类型。禁用后缀模式匹配和为内容协商使用路径扩展可以降低风险，但不足以防止RFD攻击。<br>为了防止RFD攻击，在呈现响应体之前，Spring MVC添加了一个<code>Content-Disposition:inline;filename=f.txt</code>头，以建议一个固定且安全的下载文件。只有当URL路径包含一个文件扩展名，该文件扩展名既不在白名单中，也没有显式注册用于内容协商时，才会执行此操作。然而，当url被直接输入浏览器时，它可能会有副作用。<br>默认情况下，许多公共路径扩展都是白名单。具有自定义<code>HttpMessageConverter</code>实现的应用程序可以显式注册用于内容协商的文件扩展名，以避免为这些扩展添加<code>Content-Disposition</code>头。<br>See <a href="https://pivotal.io/security/cve-2015-5211" target="_blank" rel="noopener">CVE-2015-5211</a> for additional recommendations related to RFD.  </p>
<h5 id="E-Consumable-Media-Types"><a href="#E-Consumable-Media-Types" class="headerlink" title="E. Consumable Media Types"></a>E. Consumable Media Types</h5><p>可以根据请求的<code>Content-Type</code>进一步精确映射，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/pets"</span>, consumes = <span class="string">"application/json"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPet</span><span class="params">(@RequestBody Pet pet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>consumes</code>属性还支持否定表达式，如<code>!text/plain</code>表示除<code>text/plain</code>之外的任何内容类型。<br>可以在类级别声明共享的<code>consumes</code>属性。但是，与大多数其他请求映射属性不同，当在类级别使用时，方法级别的<code>consuming</code>属性会覆盖而不是扩展在类级别上的声明。</p>
<blockquote>
<p><code>MediaType</code>为常用的媒体类型(如<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code>)的常量。</p>
</blockquote>
<h5 id="F-Producible-Media-Types"><a href="#F-Producible-Media-Types" class="headerlink" title="F. Producible Media Types"></a>F. Producible Media Types</h5><p>可以根据<code>Accept</code>请求头和控制器方法生成的内容类型列表缩小请求映射，如下面的示例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, produces = <span class="string">"application/json;charset=UTF-8"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>媒体类型可以指定一个字符集。支持反表达式，例如，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何内容类型。</p>
<blockquote>
<p>对于JSON内容类型，即使RFC7159明确声明“没有为这个注册定义字符集参数”，也应该指定UTF-8字符集，因为一些浏览器要求它正确解释UTF-8特殊字符。</p>
</blockquote>
<p>可以在类级别声明共享的<code>produces</code>属性。与大多数其他请求映射属性不同，当在类级别使用时，方法级别<code>produces</code>属性会覆盖而不是扩展类级别声明。</p>
<blockquote>
<p><code>MediaType</code> provides constants for commonly used media types, such as <code>APPLICATION_JSON_UTF8_VALUE</code> and <code>APPLICATION_XML_VALUE</code>.</p>
</blockquote>
<h5 id="G-Parameters-headers"><a href="#G-Parameters-headers" class="headerlink" title="G. Parameters, headers"></a>G. Parameters, headers</h5><p>可以根据请求参数条件缩小请求映射。您可以测试请求参数(<code>myParam</code>)是否存在、是否缺少一个(<code>!myParam</code>)或特定值(<code>myParam=myValue</code>)。下面的例子展示了如何测试一个特定的值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, params = <span class="string">"myParam=myValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样也可以使用请求头条件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets"</span>, headers = <span class="string">"myHeader=myValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>You can match <code>Content-Type</code> and <code>Accept</code> with the headers condition, but it is better to use <code>consumes</code> and <code>produces</code> instead.</p>
</blockquote>
<h5 id="H-HTTP-HEAD-OPTIONS"><a href="#H-HTTP-HEAD-OPTIONS" class="headerlink" title="H. HTTP HEAD, OPTIONS"></a>H. HTTP HEAD, OPTIONS</h5><p><code>@GetMapping</code>(和<code>@RequestMapping(method=HttpMethod.GET)</code>)对请求映射支持HTTP头。控制器方法不需要更改。<code>javax.servlet.http.HttpServlet</code>的响应包装器确保将<code>Content-Length</code>头设置为写入的字节数(不实际写入响应)。<br><code>@GetMapping</code>(和<code>@RequestMapping(method=HttpMethod.GET)</code>)被隐式映射到并支持HTTP HEAD。处理HTTP头请求时，就像处理HTTP GET一样，只是不写入主体，而是计算字节数并设置<code>Content-Length</code>头。<br>默认情况下，HTTP OPTIONS是通过将<code>Allow</code>响应头设置为所有具有匹配URL模式的<code>@RequestMapping</code>方法中列出的HTTP方法列表来处理的。<br>对于没有HTTP方法声明的<code>@RequestMapping</code>，<code>Allow</code>头被设置为GET、HEAD、POST、PUT、PATCH、DELETE和OPTIONS。控制器方法应该始终声明所支持的HTTP方法(例如，通过使用HTTP方法的特定变体:<code>@GetMapping</code>、<code>@PostMapping</code>和其他)。<br>可以显式地将<code>@RequestMapping</code>方法映射到HTTP HEAD和HTTP OPTIONS，但在一般情况下这不是必需的。  </p>
<h5 id="I-Custom-Annotations"><a href="#I-Custom-Annotations" class="headerlink" title="I. Custom Annotations"></a>I. Custom Annotations</h5><p>Spring MVC支持使用组合注解进行请求映射。这些注解本身是用<code>@RequestMapping</code>进行元注释的，它们组合在一起是为了重新声明<code>@RequestMapping</code>属性的子集(或所有)，具有更确定的用途。<br><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>和<code>@PatchMapping</code>是复合注解的例子。之所以提供这些方法，是因为大多数控制器方法应该映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code>，默认情况下，<code>@RequestMapping</code>匹配所有HTTP方法。如果需要复合注释的示例，请查看这些注解的定义。<br>Spring MVC还支持带有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要子类化<code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，在该方法中，您可以检查自定义属性并返回您自己的<code>RequestCondition</code>。  </p>
<h5 id="J-Explicit-Registrations"><a href="#J-Explicit-Registrations" class="headerlink" title="J. Explicit Registrations"></a>J. Explicit Registrations</h5><p>可以通过代码注册handler方法，这些方法可以用于动态注册或高级情况(如相同handler在不同url下的不同实例)。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandlerMapping</span><span class="params">(RequestMappingHandlerMapping mapping, UserHandler handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestMappingInfo info = RequestMappingInfo</span><br><span class="line">                .paths(<span class="string">"/user/&#123;id&#125;"</span>).methods(RequestMethod.GET).build();</span><br><span class="line"></span><br><span class="line">        Method method = UserHandler.class.getMethod(<span class="string">"getUser"</span>, Long.class);</span><br><span class="line"></span><br><span class="line">        mapping.registerMapping(info, handler, method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-Handler-Methods"><a href="#3-3-Handler-Methods" class="headerlink" title="3.3 Handler Methods"></a>3.3 Handler Methods</h4><p><code>@RequestMapping</code> handler方法具有灵活的签名，可以从一系列受支持的控制器方法参数和返回值中进行选择。</p>
<h5 id="A-Method-Arguments"><a href="#A-Method-Arguments" class="headerlink" title="A. Method Arguments"></a>A. Method Arguments</h5><p>下表描述了所支持的controller 方法参数。Reactive types are not supported for any arguments.<br>JDK 8的<code>java.util.Optional</code>支持作为方法参数与具有<code>required</code>属性的注解(例如<code>@RequestParam</code>、<code>@RequestHeader等</code>)结合，并且等效于<code>required=false</code>。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Controller method argument</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>WebRequest</code>, <code>NativeWebRequest</code></td>
<td style="text-align:left">对请求参数和请求和会话属性的通用访问，而不直接使用Servlet API。</td>
</tr>
<tr>
<td style="text-align:center">javax.servlet.ServletRequest, javax.servlet.ServletResponse</td>
<td style="text-align:left">选择任何特定的请求或响应类型，如，<code>ServletRequest</code>、<code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code>、<code>MultipartHttpServletRequest</code>。</td>
</tr>
<tr>
<td style="text-align:center">javax.servlet.http.HttpSession</td>
<td style="text-align:left">强制会话的存在。因此，这样的参数永远不会为<code>null</code>。注意，会话访问不是线程安全的。如果允许多个请求同时访问一个会话，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标志设置为<code>true</code>。</td>
</tr>
<tr>
<td style="text-align:center">javax.servlet.http.PushBuilder</td>
<td style="text-align:left">编程HTTP/2资源推送的Servlet 4.0 push builder API。注意，根据Servlet规范，如果客户机不支持HTTP/2特性，则注入的<code>PushBuilder</code>实例可以为null。</td>
</tr>
<tr>
<td style="text-align:center">java.security.Principal</td>
<td style="text-align:left">当前经过身份验证的用户——如果已知，可能是特定的<code>Principal</code>实现类。</td>
</tr>
<tr>
<td style="text-align:center">HttpMethod</td>
<td style="text-align:left">The HTTP method of the request</td>
</tr>
<tr>
<td style="text-align:center">java.util.Locale</td>
<td style="text-align:left">当前请求的locale，由最特定的可用<code>LocaleResolver</code>确定(实际上，是已配置的<code>LocaleResolve</code>r或<code>LocaleContextResolver</code>)。</td>
</tr>
<tr>
<td style="text-align:center">java.util.TimeZone + java.time.ZoneId</td>
<td style="text-align:left">与当前请求关联的时区，由<code>LocaleContextResolver</code>确定</td>
</tr>
<tr>
<td style="text-align:center"><code>java.io.InputStream</code>, <code>java.io.Reader</code></td>
<td style="text-align:left">For access to the raw request body as exposed by the Servlet API.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td style="text-align:left">For access to the raw response body as exposed by the Servlet API.</td>
</tr>
<tr>
<td style="text-align:center">@PathVariable</td>
<td style="text-align:left">For access to URI template variables.</td>
</tr>
<tr>
<td style="text-align:center">@MatrixVariable</td>
<td style="text-align:left">For access to name-value pairs in URI path segments.</td>
</tr>
<tr>
<td style="text-align:center">@RequestParam</td>
<td style="text-align:left">用于访问Servlet请求参数，包括多部件文件(multipart files)。参数值转换为声明的方法参数类型。</td>
</tr>
<tr>
<td style="text-align:center">@RequestHeader</td>
<td style="text-align:left">For access to request headers. Header values are converted to the declared method argument type.</td>
</tr>
<tr>
<td style="text-align:center">@CookieValue</td>
<td style="text-align:left">For access to cookies. Cookies values are converted to the declared method argument type.</td>
</tr>
<tr>
<td style="text-align:center">@RequestBody</td>
<td style="text-align:left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageConverter</code> implementations.</td>
</tr>
<tr>
<td style="text-align:center">HttpEntity<b></b></td>
<td style="text-align:left">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>.</td>
</tr>
<tr>
<td style="text-align:center">@RequestPart</td>
<td style="text-align:left">For access to a part in a <code>multipart/form-data</code> request, converting the part’s body with an <code>HttpMessageConverter</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td style="text-align:left">For access to the model that is used in HTML controllers and exposed to templates as part of view rendering.</td>
</tr>
<tr>
<td style="text-align:center">RedirectAttributes</td>
<td style="text-align:left">指定重定向(即附加到查询字符串)时使用的属性，以及临时存储的flash属性，直到重定向后的请求。</td>
</tr>
<tr>
<td style="text-align:center">@ModelAttribute</td>
<td style="text-align:left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes). See “Any other argument” at the end of this table.</td>
</tr>
<tr>
<td style="text-align:center">Errors, BindingResult</td>
<td style="text-align:left">用于访问来自推荐的对象(即<code>@ModelAttribute</code>参数)的验证和数据绑定的错误，或来自<code>@RequestBody</code>或<code>@RequestPart</code>参数的验证的错误。必须在验证方法参数之后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td>
</tr>
<tr>
<td style="text-align:center"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td>
<td style="text-align:left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation.</td>
</tr>
<tr>
<td style="text-align:center">UriComponentsBuilder</td>
<td style="text-align:left">For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping.</td>
</tr>
<tr>
<td style="text-align:center">@SessionAttribute</td>
<td style="text-align:left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration.</td>
</tr>
<tr>
<td style="text-align:center">@RequestAttribute</td>
<td style="text-align:left">For access to request attributes.</td>
</tr>
<tr>
<td style="text-align:center">Any other argument</td>
<td style="text-align:left">If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by BeanUtils#isSimpleProperty, it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</td>
</tr>
</tbody>
</table>
<h5 id="B-Return-Values"><a href="#B-Return-Values" class="headerlink" title="B. Return Values"></a>B. Return Values</h5><p>The next table describes the supported controller method return values. Reactive types are supported for all return values.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Controller method return value</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@ResponseBody</td>
<td style="text-align:left">The return value is converted through HttpMessageConverter implementations and written to the response.</td>
</tr>
<tr>
<td style="text-align:center">HttpEntity<b>, ResponseEntity<b></b></b></td>
<td style="text-align:left">The return value that specifies the full response (including HTTP headers and body) is to be converted through <code>HttpMessageConverter</code> implementations and written to the response.</td>
</tr>
<tr>
<td style="text-align:center">HttpHeaders</td>
<td style="text-align:left">For returning a response with headers and no body.</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a Model argument.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td style="text-align:left">Attributes to be added to the implicit model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td>
</tr>
<tr>
<td style="text-align:center">@ModelAttribute</td>
<td style="text-align:left">An attribute to be added to the model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>. Note that <code>@ModelAttribute</code> is optional.</td>
</tr>
<tr>
<td style="text-align:center"><code>ModelAndView</code> object</td>
<td style="text-align:left">The view and model attributes to use and, optionally, a response status.</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:left">如果具有<code>void</code>返回类型(或<code>null</code>返回值)的方法还具有<code>ServletResponse</code>、<code>OutputStream</code>参数或<code>@ResponseStatus</code>注释，则认为该方法已经完全处理了响应。The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check.</td>
</tr>
<tr>
<td style="text-align:center">DeferredResult<v></v></td>
<td style="text-align:left">Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback.</td>
</tr>
<tr>
<td style="text-align:center">Callable<v></v></td>
<td style="text-align:left">Produce any of the above return values asynchronously in a Spring MVC-managed thread.</td>
</tr>
<tr>
<td style="text-align:center">ListenableFuture<v>, java.util.concurrent.CompletionStage<v>, java.util.concurrent.CompletableFuture<v></v></v></v></td>
<td style="text-align:left">Alternative to DeferredResult, as a convenience (for example, when an underlying service returns one of those).</td>
</tr>
<tr>
<td style="text-align:center"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td>
<td style="text-align:left">Emit a stream of objects asynchronously to be written to the response with <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>.</td>
</tr>
<tr>
<td style="text-align:center">StreamingResponseBody</td>
<td style="text-align:left">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a <code>ResponseEntity</code>.</td>
</tr>
<tr>
<td style="text-align:center">Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td>
<td style="text-align:left">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>) collected to a <code>List</code>. For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code> blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.</td>
</tr>
<tr>
<td style="text-align:center">Any other return value</td>
<td style="text-align:left">Any return value that does not match any of the earlier values in this table and that is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by BeanUtils#isSimpleProperty. Values that are simple types remain unresolved.</td>
</tr>
</tbody>
</table>
<h5 id="C-Type-Conversion"><a href="#C-Type-Conversion" class="headerlink" title="C. Type Conversion"></a>C. Type Conversion</h5><p>如果参数声明为<code>String</code>以外的其他东西，那么基于<code>String</code>的请求输入的一些带注解的控制器方法参数(例如<code>@RequestParam</code>、<code>@RequestHeader</code>、<code>@PathVariable</code>、<code>@MatrixVariable</code>和<code>@CookieValue</code>)可能需要类型转换。<br>对于这种情况，类型转换将根据配置的转换器自动应用。默认情况下，支持简单类型(<code>int</code>、<code>long</code>、<code>Date</code>和其他类型)。可以通过<code>WebDataBinder</code>或通过向<code>FormattingConversionService</code>注册<code>Formatters</code>来定制类型转换。  </p>
<h5 id="D-Matrix-Variables"><a href="#D-Matrix-Variables" class="headerlink" title="D. Matrix Variables"></a>D. Matrix Variables</h5><p><a href="https://tools.ietf.org/html/rfc3986#section-3.3" target="_blank" rel="noopener">RFC 3986</a>讨论路径段中的name-value对。在Spring MVC中，我们根据Tim Berners-Lee的一篇”旧文章”将它们称为”矩阵变量(matrix variables)”，但它们也可以称为URI路径参数(URI path parameters)。<br>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔(如<code>/cars;color=red,green;year=2012</code>)。还可以通过重复变量名指定多个值(如<code>color=red;color=green;color=blue</code>)。<br>如果一个URL包含矩阵变量，则控制器方法的请求映射必须使用URI变量来屏蔽该变量内容，并确保能够成功匹配请求，而不依赖于矩阵变量的顺序和存在性。下面的例子使用了矩阵变量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42;q=11;r=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId, @MatrixVariable <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// petId == 42</span></span><br><span class="line">    <span class="comment">// q == 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于所有路径段都可能包含矩阵变量，因此有时可能需要消除矩阵变量应该位于哪个路径变量中的歧义。下面的例子说明了如何做到这一点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11/pets/21;q=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable(name=<span class="string">"q"</span>, pathVar=<span class="string">"ownerId"</span>)</span> <span class="keyword">int</span> q1,</span></span><br><span class="line"><span class="function">        @<span class="title">MatrixVariable</span><span class="params">(name=<span class="string">"q"</span>, pathVar=<span class="string">"petId"</span>)</span> <span class="keyword">int</span> q2) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q1 == 11</span></span><br><span class="line">    <span class="comment">// q2 == 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>矩阵变量可以定义为可选的，也可以指定一个默认值，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@MatrixVariable(required=<span class="keyword">false</span>, defaultValue=<span class="string">"1"</span>)</span> <span class="keyword">int</span> q) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q == 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要获得所有矩阵变量，可以使用<code>MultiValueMap</code>，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,</span></span></span><br><span class="line"><span class="function"><span class="params">        @MatrixVariable(pathVar=<span class="string">"petId"</span>)</span> MultiValueMap&lt;String, String&gt; petMatrixVars) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]</span></span><br><span class="line">    <span class="comment">// petMatrixVars: ["q" : 22, "s" : 23]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Note that you need to enable the use of matrix variables.在MVC Java配置中，需要使用<code>removeSemicolonContent=false</code>通过路径匹配设置<code>UrlPathHelper</code>。在MVC XML名称空间中，您可以设置<code>&lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</code>。  </p>
<h5 id="E-RequestParam"><a href="#E-RequestParam" class="headerlink" title="E. @RequestParam"></a>E. <code>@RequestParam</code></h5><p>可以使用<code>@RequestParam</code>注解将Servlet请求参数(即查询参数或表单数据)绑定到controller中的方法的参数。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pets"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setupForm</span><span class="params">(@RequestParam(<span class="string">"petId"</span>)</span> <span class="keyword">int</span> petId, Model model) </span>&#123;</span><br><span class="line">        Pet pet = <span class="keyword">this</span>.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(<span class="string">"pet"</span>, pet);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，使用此注解的方法参数是必需的，但是可以通过将<code>@RequestParam</code>注释的<code>required</code>标志设置为<code>false</code>或使用<code>java.util.Optional</code>来声明参数，以指定方法参数是可选的包装器。<br>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。<br>将参数类型声明为数组或列表允许为同一个参数名解析多个参数值。<br>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>，而没有在注解中指定参数名时，将使用每个给定参数名的参数值填充映射。<br>注意，使用<code>@RequestParam</code>是可选的(如，设置它的属性)。默认情况下，任何简单值类型(由BeanUtils#isSimpleProperty决定)和没被任何其他参数解析器解析的参数，都默认它被<code>@RequestParam</code>注解一样。</p>
<h5 id="F-RequestHeader"><a href="#F-RequestHeader" class="headerlink" title="F. @RequestHeader"></a>F. <code>@RequestHeader</code></h5><p>可以使用<code>@RequestHeader</code>注解将请求头绑定到控制器中的方法参数。<br>假设一个请求，请求头是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:8080</span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=0.9</span><br><span class="line">Accept-Language         fr,en-gb;q=0.7,en;q=0.3</span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Keep-Alive              300</span><br></pre></td></tr></table></figure></p>
<p>下面的示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code>头信息的值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestHeader(<span class="string">"Accept-Encoding"</span>)</span> String encoding,</span></span><br><span class="line"><span class="function">        @<span class="title">RequestHeader</span><span class="params">(<span class="string">"Keep-Alive"</span>)</span> <span class="keyword">long</span> keepAlive) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。<br>当在<code>Map&lt;String, String&gt;</code>、<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code>注解时，map将填充所有头部值。  </p>
<blockquote>
<p>内置支持将逗号分隔的字符串转换为类型转换系统已知的数组或字符串集合或其他类型。例如，<code>@RequestHeader(“Accept”)</code>注解的方法参数可以是<code>String</code>类型，也可以是<code>String[]</code>或List<string>。  </string></p>
</blockquote>
<h5 id="G-CookieValue"><a href="#G-CookieValue" class="headerlink" title="G. @CookieValue"></a>G. <code>@CookieValue</code></h5><p>可以使用<code>@CookieValue</code>注解将HTTP cookie的值绑定到控制器中的方法的参数。<br>假设一个请求有以下cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure></p>
<p>下路展示了如何获取cookie：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@CookieValue(<span class="string">"JSESSIONID"</span>)</span> String cookie) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。</p>
<h5 id="H-ModelAttribute"><a href="#H-ModelAttribute" class="headerlink" title="H. @ModelAttribute"></a>H. <code>@ModelAttribute</code></h5><p>可以在方法参数上使用<code>@ModelAttribute</code>注解从model中访问属性，或者在不存在model的情况下实例化它。model属性还与名称与字段名称匹配的HTTP Servlet请求参数的值重叠。这称为数据绑定，它使您不必解析和转换单个查询参数和表单字段。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@ModelAttribute Pet pet)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Pet</code>实例按如下解析：</p>
<ul>
<li>From the model if already added by using Model.</li>
<li>From the HTTP session by using <code>@SessionAttributes</code>.</li>
<li>From a URI path variable passed through a <code>Converter</code> (see the next example).</li>
<li>From the invocation of a default constructor.</li>
<li>From the invocation of a “primary constructor” with arguments that match to Servlet request parameters. Argument names are determined through JavaBeans <code>@ConstructorProperties</code> or through runtime-retained parameter names in the bytecode.</li>
</ul>
<p>虽然通常使用Model来填充属性到模型中，但是另一种方法是依赖<code>Converter&lt;String, T&gt;</code>加上URI路径变量约定。在下面的示例中，模型属性名, <code>account</code>，匹配URI路径变量<code>account</code>，并且通过注册的转换器传递字符串帐号来加载<code>Account</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/accounts/&#123;account&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@ModelAttribute(<span class="string">"account"</span>)</span> Account account) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取模型属性实例后，就会应用数据绑定。<code>WebDataBinder</code>类将Servlet请求参数名称(查询参数和表单字段)匹配到目标对象上的字段名称。如果需要，匹配字段将在应用类型转换之后填充。<br>数据绑定可能导致错误。默认情况下，会引发<code>BindException</code>。要在控制器方法中检查这些错误，可以在<code>@ModelAttribute</code>旁边添加一个<code>BindingResult</code>参数，如下面的示例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@ModelAttribute(<span class="string">"pet"</span>)</span> Pet pet, BindingResult result) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在某些情况下，可能希望访问模型属性而不需要数据绑定。对于这种情况，可以将<code>Model</code>注入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code>，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AccountForm <span class="title">setUpForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountForm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">findAccount</span><span class="params">(@PathVariable String accountId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findOne(accountId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(@Valid AccountForm form, BindingResult result,</span></span></span><br><span class="line"><span class="function"><span class="params">        @ModelAttribute(binding=<span class="keyword">false</span>)</span> Account account) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过添加<code>javax.validation.Valid</code>注解或Spring的<code>@Validated</code>注解，可以在数据绑定之后自动应用验证。如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(@Valid @ModelAttribute(<span class="string">"pet"</span>)</span> Pet pet, BindingResult result) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"petForm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，使用<code>@ModelAttribute</code>是可选的(例如，设置它的属性)。默认情况下，任何不是简单值类型的参数(由BeanUtils#isSimpleProperty决定)或者没被任何其他参数解析器解析的参数都被视为带有<code>@ModelAttribute</code>注解。</p>
<h5 id="I-SessionAttributes"><a href="#I-SessionAttributes" class="headerlink" title="I. @SessionAttributes"></a>I. <code>@SessionAttributes</code></h5><p><code>@SessionAttributes</code>用于在请求之间的HTTP Servlet session中存储model属性。它是一个类型级别的注释，声明特定controller使用的会话属性。这通常列出模型属性的名称或类型，这些属性应该透明地存储在会话中，以便后续请求访问。下面的示例使用<code>@SessionAttributes</code>注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"pet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一个请求中，当名为pet的模型属性被添加到模型中时，它将自动提升到HTTP Servlet会话并保存在会话中，直到另一个控制器方法使用<code>SessionStatus</code>方法参数清空存储。如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"pet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/pets/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Pet pet, BindingResult errors, SessionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">            status.setComplete();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="J-SessionAttribute"><a href="#J-SessionAttribute" class="headerlink" title="J. @SessionAttribute"></a>J. <code>@SessionAttribute</code></h5><p>如果需要访问全局管理(也就是说在控制器之外，如通过过滤器)的预先存在的会话属性，并且可能不存在，也可能不存在，那么可以在方法参数上使用<code>@SessionAttribute</code>注解，如下面的示例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@SessionAttribute User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于需要添加或删除会话属性的用例，可以考虑注入<code>org.springframework.web.context.request.WebRequest</code>或<code>javax.servlet.http.HttpSession</code>到控制器方法。<br>对于作为控制器工作流一部分的会话中的模型属性的临时存储，可以考虑使用<code>@SessionAttributes</code>。  </p>
<h5 id="K-RequestAttribute"><a href="#K-RequestAttribute" class="headerlink" title="K. @RequestAttribute"></a>K. <code>@RequestAttribute</code></h5><p>与<code>@SessionAttribute</code>类似，可以使用<code>@RequestAttribute</code>注解访问先前创建的已有请求属性(例如，通过Servlet <code>Filter</code>或<code>HandlerInterceptor</code>):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@RequestAttribute Client client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="L-Redirect-Attributes"><a href="#L-Redirect-Attributes" class="headerlink" title="L. Redirect Attributes"></a>L. Redirect Attributes</h5><p>默认情况下，所有模型属性都被认为是作为重定向URL中的URI模板变量公开的。在其余属性中，那些是基本类型或基本类型的集合或数组的属性将自动附加为查询参数。<br>如果模型实例是专门为重定向准备的，那么将原始类型属性附加为查询参数可能是理想的结果。但是，在带注解的控制器中，model可以包含为以呈现为目的而添加的附加属性(例如，下拉字段值)。为了避免这种属性出现在URL中，<code>@RequestMapping</code>方法可以声明一个类型为<code>RedirectAttributes</code>的参数，并使用它指定<code>RedirectView</code>可用的确切属性。如果方法确实重定向，则使用<code>RedirectAttributes</code>的内容。否则，将使用模型的内容。<br><code>RequestMappingHandlerAdapter</code>提供了一个名为<code>ignoreDefaultModelOnRedirect</code>的标志，可以使用它来指示如果控制器方法重定向，则永远不应该使用默认<code>Model</code>的内容。相反，控制器方法应该声明<code>RedirectAttributes</code>类型的属性，或者，如果没有这样做，就不应该将任何属性传递给<code>RedirectView</code>。MVC名称空间和MVC Java配置都将此标志设置为<code>false</code>，以保持向后兼容性。但是，对于新的应用程序，我们建议将其设置为<code>true</code>。<br>注意，当展开重定向URL时，当前请求中的URI模板变量是自动可用的，不需要显式地通过<code>Model</code>或<code>RedirectAttributes</code>添加它们。下面的例子展示了如何定义重定向:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/files/&#123;path&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:files/&#123;path&#125;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种将数据传递到重定向目标的方法是使用flash属性。与其他重定向属性不同，flash属性保存在HTTP会话中(因此不会出现在URL中)。</p>
<h5 id="M-Flash-Attributes"><a href="#M-Flash-Attributes" class="headerlink" title="M. Flash Attributes"></a>M. Flash Attributes</h5><p>Flash属性为一个请求提供了一种方法来存储用于另一个请求的属性。这是在重定向时最常见的需要—例如，后Post-Redirect-Get模式。Flash属性在重定向之前临时保存(通常在会话中)，以便在重定向之后对请求可用，并立即删除。<br>Spring MVC有两个主要抽象来支持flash属性。<code>FlashMap</code>用于保存flash属性，而<code>FlashMapManager</code>用于存储、检索和管理<code>FlashMap</code>实例。<br>Flash属性支持总是启用的，不需要显式启用。但是，如果不使用它，它永远不会导致HTTP会话创建。对于每个请求，都有一个“输入”FlashMap和一个“输出”FlashMap，前者带有前一个请求传递的属性(如果有的话)，后者带有属性，以便保存为后续请求。这两个FlashMap实例都可以通过<code>RequestContextUtils</code>中的静态方法从Spring MVC中的任何地方访问。<br>带注解的控制器通常不需要直接使用<code>FlashMap</code>。相反，<code>@RequestMapping</code>方法可以接受<code>RedirectAttributes</code>类型的参数，并使用它为重定向场景添加flash属性。通过<code>RedirectAttributes</code>添加的Flash属性会自动传播到“output”FlashMap。类似地，在重定向之后，来自“input”FlashMap的属性将自动添加到服务于目标URL的控制器的模型中。  </p>
<blockquote>
<p>Matching requests to flash attributes<br>The concept of flash attributes exists in many other web frameworks and has proven to sometimes be exposed to concurrency issues. This is because, by definition, flash attributes are to be stored until the next request. However the very “next” request may not be the intended recipient but another asynchronous request (for example, polling or resource requests), in which case the flash attributes are removed too early.<br>To reduce the possibility of such issues, RedirectView automatically “stamps” <code>FlashMap</code> instances with the path and query parameters of the target redirect URL. In turn, the default <code>FlashMapManager</code> matches that information to incoming requests when it looks up the “input” <code>FlashMap</code>.<br>This does not entirely eliminate the possibility of a concurrency issue but reduces it greatly with information that is already available in the redirect URL. Therefore, we recommend that you use flash attributes mainly for redirect scenarios.  </p>
</blockquote>
<h5 id="N-Multipart"><a href="#N-Multipart" class="headerlink" title="N. Multipart"></a>N. Multipart</h5><p>当一个<code>MultipartResolver</code>启用后，使用<code>multipart/form-data</code>的POST请求的内容将被解析，并以常规的请求参数被访问。下面的示例访问一个常规表单字段和一个上传文件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将参数类型声明为<code>List&lt;MultipartFile&gt;</code>允许为相同的参数名称解析多个文件。<br>当<code>@RequestParam</code>注解声明为<code>Map&lt;String, MultipartFile&gt;</code>或<code>MultiValueMap&lt;String, MultipartFile&gt;</code>，而没有在注解中指定参数名时，将使用每个给定参数名的多部分文件填充映射。  </p>
<blockquote>
<p>With Servlet 3.0 multipart parsing, you may also declare <code>javax.servlet.http.Part</code> instead of Spring’s <code>MultipartFile</code>, as a method argument or collection value type.</p>
</blockquote>
<p>还可以使用多部分内容作为到对象的数据绑定的一部分。例如，上例中的表单字段和文件可以是表单对象上的字段，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/form"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(MyForm form, BindingResult errors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!form.getFile().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = form.getFile().getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:uploadSuccess"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:uploadFailure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在RESTful服务场景中，还可以从非浏览器客户端提交多部件请求。下例演示了一个JSON文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;meta-data&quot;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>@RequestParam</code>以字符串形式访问“元数据”部分，但是您可能希望它从JSON反序列化(类似于<code>@RequestBody</code>)。在使用HttpMessageConverter转换多部件之后，使用<code>@RequestPart</code>注解访问它:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@RequestPart(<span class="string">"meta-data"</span>)</span> MetaData metadata,</span></span><br><span class="line"><span class="function">        @<span class="title">RequestPart</span><span class="params">(<span class="string">"file-data"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以组合使用<code>@RequestPart</code>和<code>javax.validation.Valid</code>或使用Spring的<code>@Validated</code>注解，这两种方法都会应用Standard Bean Validation。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>异常，该异常将转换为400(BAD_REQUEST)响应。或者，可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器中本地处理验证错误，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(@Valid @RequestPart(<span class="string">"meta-data"</span>)</span> MetaData metadata,</span></span><br><span class="line"><span class="function">        BindingResult result) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="O-RequestBody"><a href="#O-RequestBody" class="headerlink" title="O. @RequestBody"></a>O. <code>@RequestBody</code></h5><p>可以使用<code>@RequestBody</code>注解让请求的body通过<code>HttpMessageConverter</code>读取并反序列化为对象。下面的示例使用<code>@RequestBody</code>参数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@RequestBody Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以使用MVC配置的Message Converters(消息转换器)选项来配置或自定义消息转换。<br>可以组合使用<code>@RequestBody</code>和<code>javax.validation.Valid</code>或Spring的<code>@Validated</code>注解，这两个注解都会应用Standard Bean Validation。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>异常，该异常将转换为400(BAD_REQUEST)响应。或者，可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器中本地处理验证错误，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@Valid @RequestBody Account account, BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="P-HttpEntity"><a href="#P-HttpEntity" class="headerlink" title="P. HttpEntity"></a>P. HttpEntity</h5><p><code>HttpEntity</code>或多或少与使用<code>@RequestBody</code>相同，但它基于一个暴露request headers和body的容器对象。例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/accounts"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpEntity&lt;Account&gt; entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Q-ResponseBody"><a href="#Q-ResponseBody" class="headerlink" title="Q. @ResponseBody"></a>Q. <code>@ResponseBody</code></h5><p>可以使用方法上的<code>@ResponseBody</code>注解，通过<code>HttpMessageConverter</code>将返回序列化到响应体。下面的清单显示了一个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/accounts/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@ResponseBody</code>在类级也受支持，在这种情况下，它被所有控制器方法继承。这就是<code>@RestController</code>的作用，它只不过是一个用<code>@Controller</code>和<code>@ResponseBody</code>注解的注解。<br>You can use <code>@ResponseBody</code> with reactive types.</p>
<h5 id="R-ResponseEntity"><a href="#R-ResponseEntity" class="headerlink" title="R. ResponseEntity"></a>R. ResponseEntity</h5><p><code>ResponseEntity</code>类似于<code>@ResponseBody</code>，但是有status和header。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/something"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String body = ... ;</span><br><span class="line">    String etag = ... ;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring MVC supports using a single value reactive type to produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types for the body.</p>
<h5 id="S-Jackson-JSON"><a href="#S-Jackson-JSON" class="headerlink" title="S. Jackson JSON"></a>S. Jackson JSON</h5><p>Spring提供了对Jackson JSON库的支持。  </p>
<p><strong>JSON Views</strong></p>
<p>Spring MVC为Jackson的序列化视图提供了内置的支持，它允许只呈现对象中的字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，可以使用Jackson的<code>@JsonView</code>注释来激活序列化视图类，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="meta">@JsonView</span>(User.WithoutPasswordView.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"eric"</span>, <span class="string">"7!jd#h23"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithPasswordView</span> <span class="keyword">extends</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView</span>(WithoutPasswordView.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView</span>(WithPasswordView.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@JsonView</code> allows an array of view classes, but you can specify only one per controller method. If you need to activate multiple views, you can use a composite interface.  </p>
</blockquote>
<p>对于依赖于视图解析的控制器，可以将serialization view类添加到模型中，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">AbstractController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, <span class="keyword">new</span> User(<span class="string">"eric"</span>, <span class="string">"7!jd#h23"</span>));</span><br><span class="line">        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"userView"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-Model"><a href="#3-4-Model" class="headerlink" title="3.4 Model"></a>3.4 Model</h4><p>当<code>@ModelAttribute</code>注解：</p>
<ul>
<li>在一个<code>@RequestMapping</code>注解的方法的参数上使用时，可以创建或获得model中的对象，并通过<code>WebDataBinder</code>与请求绑定。</li>
<li>在<code>@Controller</code>或<code>@ControllerAdvice</code>注解的类的方法上时，可以在任何<code>@RequestMapping</code>方法调用之前来初始化模型。</li>
<li>在<code>@RequestMapping</code>注解的方法上，来标记此方法的返回值是一个model属性。</li>
</ul>
<p>本节讨论<code>@ModelAttribute</code>方法，即上面列出的第二种使用方法。控制器可以有任意数量的<code>@ModelAttribute</code>方法。所有这些方法都在同一控制器中的<code>@RequestMapping</code>方法之前调用。<code>@ModelAttribute</code>方法也可以通过<code>@ControllerAdvice</code>在控制器之间共享。<br><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的参数，除了<code>@ModelAttribute</code>本身或任何与request body相关的参数。<br>下例展示了一个<code>@ModelAttribute</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateModel</span><span class="params">(@RequestParam String number, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下例只添加了一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(@RequestParam String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果没有显式指定名称，则根据对象类型选择默认名称，正如javadoc for <code>Conventions</code>约定中所解释的那样。总是可以使用重载的<code>addAttribute</code>方法或通过<code>@ModelAttribute</code>上的<code>name</code>属性指定显式名称。  </p>
</blockquote>
<p>还可以使用<code>@ModelAttribute</code>作为<code>@RequestMapping</code>方法上的方法级别注解，在这种情况下，<code>@RequestMapping</code>方法的返回值被解释为 a model attribute。这通常不是必需的，因为这是HTML控制器中的默认行为，除非返回值是一个<code>String</code>(将被解释为视图名)。<code>@ModelAttribute</code>还可以自定义模型属性名，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/accounts/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"myAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-DataBinder"><a href="#3-5-DataBinder" class="headerlink" title="3.5 DataBinder"></a>3.5 <code>DataBinder</code></h4><p><code>@Controller</code>或<code>@ControllerAdvice</code>类可以有<code>@InitBinder</code>方法来初始化<code>WebDataBinder</code>的实例，而这些实例又可以:</p>
<ul>
<li>将请求参数(即表单或查询数据)绑定到模型对象。</li>
<li>将基于字符串的请求值(如请求参数、路径变量、标头、cookie等)转换为控制器方法参数的目标类型。</li>
<li>在呈现HTML表单时，将模型对象值格式化为字符串值。</li>
</ul>
<p><code>@InitBinder</code>方法可以注册控制器特定的<code>java.bean.PropertyEditor</code>或Spring <code>Converter</code>和<code>Formatter</code>组件。此外，还可以使用MVC配置在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>。<br><code>@InitBinder</code>方法支持许多<code>@RequestMapping</code>方法支持的参数，除了<code>@ModelAttribute</code>(command object)参数。通常，它们用<code>WebDataBinder</code>参数(用于注册)和一个<code>void</code>返回值声明。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，当通过共享的<code>FormattingConversionService</code>使用基于<code>Formatter</code>的设置时，可以重用相同的方法并注册的特定于controller的<code>Formatter</code>实现，如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-6-Exceptions"><a href="#3-6-Exceptions" class="headerlink" title="3.6 Exceptions"></a>3.6 Exceptions</h4><p><code>@Controller</code>和<code>@ControllerAdvice</code>类可以有<code>@ExceptionHandler</code>方法来处理来自controller方法的异常，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">(IOException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常可以与传播出的顶级异常(即直接抛出的<code>IOException</code>)匹配，也可以与顶级包装器异常中的直接原因匹配(例如，在<code>IllegalStateException</code>中包装的<code>IOException</code>)。<br>为了匹配异常类型，最好将目标异常声明为方法参数(如上例所示)。当多个异常方法匹配时，根异常匹配通常比原因异常匹配更可取。更具体地说，<code>ExceptionDepthComparator</code>用于根据抛出异常类型的深度对异常进行排序。<br>或者，注解声明可以缩小异常类型以匹配，如下例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;FileSystemException.class, RemoteException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">(IOException ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>You can even use a list of specific exception types with a very generic argument signature，如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;FileSystemException.class, RemoteException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>The distinction between root and cause exception matching can be surprising.<br>In the <code>IOException</code> variant shown earlier, the method is typically called with the actual <code>FileSystemException</code> or <code>RemoteException</code> instance as the argument, since both of them extend from <code>IOException</code>. However, if any such matching exception is propagated within a wrapper exception which is itself an <code>IOException</code>, the passed-in exception instance is that wrapper exception.<br>The behavior is even simpler in the <code>handle(Exception)</code> variant. This is always invoked with the wrapper exception in a wrapping scenario, with the actually matching exception to be found through <code>ex.getCause()</code> in that case. The passed-in exception is the actual <code>FileSystemException</code> or <code>RemoteException</code> instance only when these are thrown as top-level exceptions.</p>
</blockquote>
<p>通常建议参数签名要尽可能具体，减少根类型和原因异常类型之间不匹配的可能性。考虑将一个多匹配的方法分解为单独的<code>@ExceptionHandler</code>方法，每个方法通过其签名匹配一个特定的异常类型。<br>在multi-<code>@ControllerAdvice</code>中，建议在按相应顺序排列优先级的<code>@ControllerAdvice</code>上声明主根异常映射。虽然根异常匹配优于原因匹配，但这是在给定控制器或<code>@ControllerAdvice</code>类的方法中定义的。这意味着优先级较高的<code>@ControllerAdvice</code>bean上的原因匹配要优于优先级较低的<code>@ControllerAdvice</code>bean上的任何匹配(例如根)。<br>最后，<code>@ExceptionHandler</code>方法实现可以选择通过将给定的异常实例以其原始形式重新抛出来退出处理。在只对根级别匹配或无法静态确定的特定上下文中的匹配感兴趣的场景中，这非常有用。重新抛出的异常将通过剩余的解析链传播，就好像给定的<code>@ExceptionHandler</code>方法一开始就不匹配一样。<br>Spring MVC中对<code>@ExceptionHandler</code>方法的支持是建立在DispatcherServlet级别的<code>HandlerExceptionResolver</code>机制之上的。  </p>
<h5 id="A-Method-Arguments-1"><a href="#A-Method-Arguments-1" class="headerlink" title="A. Method Arguments"></a>A. Method Arguments</h5><p><code>@ExceptionHandler</code>方法支持以下参数:  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Method argument</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Exception type</td>
<td style="text-align:left">For access to the raised exception.</td>
</tr>
<tr>
<td style="text-align:center">HandlerMethod</td>
<td style="text-align:left">For access to the controller method that raised the exception.</td>
</tr>
<tr>
<td style="text-align:center"><code>WebRequest</code>, <code>NativeWebRequest</code></td>
<td style="text-align:left">Generic access to request parameters and request and session attributes without direct use of the Servlet API.</td>
</tr>
<tr>
<td style="text-align:center">javax.servlet.ServletRequest, javax.servlet.ServletResponse</td>
<td style="text-align:left">Choose any specific request or response type (for example, ServletRequest or HttpServletRequest or or Spring’s MultipartRequest or MultipartHttpServletRequest).</td>
</tr>
<tr>
<td style="text-align:center">javax.servlet.http.HttpSession</td>
<td style="text-align:left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>.Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s synchronizeOnSession flag to true if multiple requests are allowed to access a session concurrently.</td>
</tr>
<tr>
<td style="text-align:center">java.security.Principal</td>
<td style="text-align:left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td>
</tr>
<tr>
<td style="text-align:center">HttpMethod</td>
<td style="text-align:left">The HTTP method of the request.</td>
</tr>
<tr>
<td style="text-align:center">java.util.Locale</td>
<td style="text-align:left">The current request locale, determined by the most specific <code>LocaleResolver</code> available — in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></td>
<td style="text-align:left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td>
<td style="text-align:left">For access to the raw response body, as exposed by the Servlet API.</td>
</tr>
<tr>
<td style="text-align:center"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td style="text-align:left">For access to the model for an error response. Always empty.</td>
</tr>
<tr>
<td style="text-align:center">RedirectAttributes</td>
<td style="text-align:left">Specify attributes to use in case of a redirect — (that is to be appended to the query string) and flash attributes to be stored temporarily until the request after the redirect.</td>
</tr>
<tr>
<td style="text-align:center">@SessionAttribute</td>
<td style="text-align:left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration.</td>
</tr>
<tr>
<td style="text-align:center">@RequestAttribute</td>
<td style="text-align:left">For access to request attributes.</td>
</tr>
</tbody>
</table>
<h5 id="B-Return-Values-1"><a href="#B-Return-Values-1" class="headerlink" title="B. Return Values"></a>B. Return Values</h5><p><code>@ExceptionHandler</code>方法支持以下返回值:  </p>
<table>
<thead>
<tr>
<th style="text-align:center">Return value</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@ResponseBody</td>
<td style="text-align:left">The return value is converted through <code>HttpMessageConverter</code> instances and written to the response.</td>
</tr>
<tr>
<td style="text-align:center">HttpEntity<b>, ResponseEntity<b></b></b></td>
<td style="text-align:left">The return value specifies that the full response (including the HTTP headers and the body) be converted through <code>HttpMessageConverter</code> instances and written to the response.</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (described earlier).</td>
</tr>
<tr>
<td style="text-align:center">View</td>
<td style="text-align:left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method may also programmatically enrich the model by declaring a <code>Model</code> argument (descried earlier).</td>
</tr>
<tr>
<td style="text-align:center"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td style="text-align:left">Attributes to be added to the implicit model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td>
</tr>
<tr>
<td style="text-align:center">@ModelAttribute</td>
<td style="text-align:left">An attribute to be added to the model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>. Note that <code>@ModelAttribute</code> is optional.</td>
</tr>
<tr>
<td style="text-align:center"><code>ModelAndView</code> object</td>
<td style="text-align:left">The view and model attributes to use and, optionally, a response status.</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code> an <code>OutputStream</code> argument, or a <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see Controllers for details). If none of the above is true, a void return type can also indicate “no response body” for REST controllers or default view name selection for HTML controllers.</td>
</tr>
<tr>
<td style="text-align:center">Any other return value</td>
<td style="text-align:left">If a return value is not matched to any of the above and is not a simple type (as determined by BeanUtils#isSimpleProperty), by default, it is treated as a model attribute to be added to the model. If it is a simple type, it remains unresolved.</td>
</tr>
</tbody>
</table>
<h5 id="C-REST-API-exceptions"><a href="#C-REST-API-exceptions" class="headerlink" title="C. REST API exceptions"></a>C. REST API exceptions</h5><p>REST服务的一个常见需求是在响应主体中包含错误细节。Spring框架不会自动这样做，因为响应体中错误细节的表示是特定于应用程序的。但是，<code>@RestController</code>可以使用带有<code>ResponseEntity</code>返回值的<code>@ExceptionHandler</code>方法来设置响应的状态和主体。还可以在<code>@ControllerAdvice</code>类中声明这些方法，以便全局应用它们。<br>在响应体中实现带有错误细节的全局异常处理的应用程序应该考虑扩展<code>ResponseEntityExceptionHandler</code>，它为Spring MVC引发的异常提供handler，并提供hook来定制响应体。要使用它，创建<code>ResponseEntityExceptionHandler</code>的子类，用<code>@ControllerAdvice</code>注释它，覆盖必要的方法，并将它声明为Spring bean。</p>
<h4 id="3-7-Controller-Advice"><a href="#3-7-Controller-Advice" class="headerlink" title="3.7 Controller Advice"></a>3.7 Controller Advice</h4><p>通常<code>@ExceptionHandler</code>、<code>@InitBinder</code>和<code>@ModelAttribute</code>方法应用于声明它们的<code>@Controller</code>类(或类层次结构)中。如果希望这些方法更全局地(跨控制器)应用，可以在一个用<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>标记的类中声明它们。<br><code>@ControllerAdvice</code>被标记为<code>@Component</code>，这意味着这些类可以通过组件扫描注册为Spring bean。<code>@RestControllerAdvice</code>也是一个由<code>@ControllerAdvice</code>和<code>@ResponseBody</code>标记的元注释，这本质上意味着<code>@ExceptionHandler</code>方法通过消息转换(相对于视图解析或模板呈现)呈现给响应体。<br>在启动时，用于<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法的基础设施类检测类型为<code>@ControllerAdvice</code>的Spring bean，然后在运行时应用它们的方法。全局<code>@ExceptionHandler</code>方法(来自<code>@ControllerAdvice</code>)在本地方法(来自<code>@Controller</code>)之后应用。相比之下，全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法在局部方法之前应用。<br>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求(即所有控制器)，但是可以使用注解上的属性将其缩小到控制器的子集，如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target all Controllers annotated with @RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(annotations = RestController.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers within specific packages</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(<span class="string">"org.example.controllers"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers assignable to specific classes</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice3</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。有关更多细节，请参见<a href="https://docs.spring.io/spring-framework/docs/5.1.6.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html" target="_blank" rel="noopener"><code>@ControllerAdvice</code> javadoc</a>。</p>
<h3 id="4-URI-Links"><a href="#4-URI-Links" class="headerlink" title="4. URI Links"></a>4. URI Links</h3><h3 id="5-Asynchronous-Requests"><a href="#5-Asynchronous-Requests" class="headerlink" title="5. Asynchronous Requests"></a>5. Asynchronous Requests</h3><h3 id="6-CORS"><a href="#6-CORS" class="headerlink" title="6. CORS"></a>6. CORS</h3><h3 id="7-Web-Security"><a href="#7-Web-Security" class="headerlink" title="7. Web Security"></a>7. Web Security</h3><h3 id="8-HTTP-Caching"><a href="#8-HTTP-Caching" class="headerlink" title="8. HTTP Caching"></a>8. HTTP Caching</h3><h3 id="9-View-Technologies"><a href="#9-View-Technologies" class="headerlink" title="9. View Technologies"></a>9. View Technologies</h3><p>Spring MVC中视图技术的使用是可插拔的，无论使用Thymeleaf、Groovy Markup Templates、jsp还是其他技术，这主要是配置更改的问题。本章将介绍Spring MVC集成的视图技术。  </p>
<h4 id="9-1-Thymeleaf"><a href="#9-1-Thymeleaf" class="headerlink" title="9.1 Thymeleaf"></a>9.1 Thymeleaf</h4><p>Thymeleaf是一个现代的服务器端Java模板引擎，它强调自然的HTML模板，可以在浏览器中通过双击预览，这对UI模板(由设计师设计)上的独立工作非常有用，不需要运行服务器。如果您想要替换jsp, Thymeleaf提供了一组最广泛的特性来简化这种转换。Thymeleaf得到了积极的开发和维护。有关更完整的介绍，请参见<a href="https://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf项目主页</a>。<br>与Spring MVC集成的Thymeleaf由Thymeleaf项目管理。配置包括一些bean声明，如<code>ServletContextTemplateResolver</code>、<code>SpringTemplateEngine</code>和<code>ThymeleafViewResolver</code>。有关更多细节，请参见<a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">Thymeleaf + Spring</a>。  </p>
<h4 id="9-2-FreeMarker"><a href="#9-2-FreeMarker" class="headerlink" title="9.2 FreeMarker"></a>9.2 FreeMarker</h4><p>Apache FreeMarker是一个模板引擎，用于生成从HTML到电子邮件等任何类型的文本输出。Spring框架有一个内置的集成，用于使用带有FreeMarker模板的Spring MVC。  </p>
<h5 id="A-View-Configuration"><a href="#A-View-Configuration" class="headerlink" title="A. View Configuration"></a>A. View Configuration</h5><p>下例演示了如何将FreeMarker配置为视图技术：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.freemarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure FreeMarker...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerConfigurer <span class="title">freeMarkerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">"/WEB-INF/freemarker"</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>XML可以这样配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-resolvers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:freemarker</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:view-resolvers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Configure FreeMarker... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:freemarker-configurer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:template-loader-path</span> <span class="attr">location</span>=<span class="string">"/WEB-INF/freemarker"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:freemarker-configurer</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或者，也可以声明<code>FreeMarkerConfigurer</code> bean来完全控制所有属性，如下面的示例所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"freemarkerConfig"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/freemarker/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>模板需要存储在上例所示的<code>FreeMarkerConfigurer</code>指定的目录中。上例配置中，如果控制器返回一个<code>welcome</code>视图名，解析器将查找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。  </p>
<h5 id="B-FreeMarker-Configuration"><a href="#B-FreeMarker-Configuration" class="headerlink" title="B. FreeMarker Configuration"></a>B. FreeMarker Configuration</h5><p>通过在<code>FreeMarkerConfigurer</code> bean上设置适当的bean属性，可以将FreeMarker ‘Settings’和’SharedVariables’直接传递给FreeMarker <code>Configuration</code>对象(由Spring管理)。<code>freemarkerSettings</code>属性需要一个<code>java.util.Properties</code>对象，而<code>freemarkerVariables</code>属性需要一个<code>java.util.Map</code>。例如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"freemarkerConfig"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"templateLoaderPath"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/freemarker/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"freemarkerVariables"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"xml_escape"</span> <span class="attr">value-ref</span>=<span class="string">"fmXmlEscape"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"fmXmlEscape"</span> <span class="attr">class</span>=<span class="string">"freemarker.template.utility.XmlEscape"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>有关应用于<code>Configuration</code>对象的设置和变量的详细信息，请参阅FreeMarker文档。</p>
<h5 id="C-Form-Handling"><a href="#C-Form-Handling" class="headerlink" title="C. Form Handling"></a>C. Form Handling</h5><p>Spring提供了一个用于jsp的标记库，其中包含一个<code>&lt;Spring:bind/&gt;</code>元素。这个元素主要让表单显示来自表单支持的对象，并显示来自web或业务层的<code>Validator</code>验证失败的结果。Spring还在FreeMarker中支持相同功能，并提供了额外的宏方便地来生成表单输入元素本身。</p>
<h6 id="⑴-The-Bind-Macros"><a href="#⑴-The-Bind-Macros" class="headerlink" title="⑴ The Bind Macros"></a>⑴ The Bind Macros</h6><h6 id="⑵-Simple-Binding"><a href="#⑵-Simple-Binding" class="headerlink" title="⑵ Simple Binding"></a>⑵ Simple Binding</h6><h6 id="⑶-Input-macros"><a href="#⑶-Input-macros" class="headerlink" title="⑶ Input macros"></a>⑶ Input macros</h6><h6 id="⑷-Input-Fields"><a href="#⑷-Input-Fields" class="headerlink" title="⑷ Input Fields"></a>⑷ Input Fields</h6><h6 id="⑸-Selection-Fields"><a href="#⑸-Selection-Fields" class="headerlink" title="⑸ Selection Fields"></a>⑸ Selection Fields</h6><h6 id="⑹-HTML-Escaping"><a href="#⑹-HTML-Escaping" class="headerlink" title="⑹ HTML Escaping"></a>⑹ HTML Escaping</h6><h4 id="9-3-Groovy-Markup"><a href="#9-3-Groovy-Markup" class="headerlink" title="9.3 Groovy Markup"></a>9.3 Groovy Markup</h4><h4 id="9-4-Script-Views"><a href="#9-4-Script-Views" class="headerlink" title="9.4 Script Views"></a>9.4 Script Views</h4><h4 id="9-5-JSP-and-JSTL"><a href="#9-5-JSP-and-JSTL" class="headerlink" title="9.5 JSP and JSTL"></a>9.5 JSP and JSTL</h4><h4 id="9-6-Tiles"><a href="#9-6-Tiles" class="headerlink" title="9.6 Tiles"></a>9.6 Tiles</h4><h4 id="9-7-RSS-and-Atom"><a href="#9-7-RSS-and-Atom" class="headerlink" title="9.7 RSS and Atom"></a>9.7 RSS and Atom</h4><h4 id="9-8-PDF-and-Excel"><a href="#9-8-PDF-and-Excel" class="headerlink" title="9.8 PDF and Excel"></a>9.8 PDF and Excel</h4><h4 id="9-9-Jackson"><a href="#9-9-Jackson" class="headerlink" title="9.9 Jackson"></a>9.9 Jackson</h4><h4 id="9-10-XML-Marshalling"><a href="#9-10-XML-Marshalling" class="headerlink" title="9.10 XML Marshalling"></a>9.10 XML Marshalling</h4><h4 id="9-11-XSLT-Views"><a href="#9-11-XSLT-Views" class="headerlink" title="9.11 XSLT Views"></a>9.11 XSLT Views</h4><h3 id="10-MVC-Config"><a href="#10-MVC-Config" class="headerlink" title="10. MVC Config"></a>10. MVC Config</h3><h3 id="11-HTTP-2"><a href="#11-HTTP-2" class="headerlink" title="11. HTTP/2"></a>11. HTTP/2</h3><p>Servlet 4容器要求支持HTTP/2, Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要做任何特定的事情。但是，还有一些与服务器配置相关的考虑事项。<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support" target="_blank" rel="noopener">Details</a><br>Servlet API确实公开了一个与HTTP/2相关的构造。可以使用<code>javax.servlet.http.PushBuilder</code>主动地将资源推送到客户端，并支持将其作为<code>@RequestMapping</code>方法的参数。</p>
<h2 id="Ⅱ-REST-Clients"><a href="#Ⅱ-REST-Clients" class="headerlink" title="Ⅱ. REST Clients"></a>Ⅱ. REST Clients</h2><p>本节描述客户端访问REST端的选项。  </p>
<h3 id="1-RestTemplate"><a href="#1-RestTemplate" class="headerlink" title="1. RestTemplate"></a>1. <code>RestTemplate</code></h3><p><code>RestTemplate</code>是执行HTTP请求的同步client。它是原始的Spring REST client，并在底层HTTP client库上公开了一个简单的模板方法API。  </p>
<blockquote>
<p>从5.0开始，reactive <code>WebClient</code>提供了<code>RestTemplate</code>的现代替代方案，对同步和异步以及流场景都提供了有效的支持。<code>RestTemplate</code>将在将来的版本中被弃用，并且将来不会添加主要的新特性。</p>
</blockquote>
<p>See <a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/integration.html#rest-client-access" target="_blank" rel="noopener">REST Endpoints</a> for details.</p>
<h3 id="2-WebClient"><a href="#2-WebClient" class="headerlink" title="2. WebClient"></a>2. <code>WebClient</code></h3><p>WebClient是执行HTTP请求的非阻塞的reactive client。它是在5.0中引入的，为<code>RestTemplate</code>提供了一个现代的替代方案，对同步和异步以及流场景都提供了有效的支持。<br>与<code>RestTemplate</code>相比，<code>WebClient</code>支持以下功能:  </p>
<ul>
<li>Non-blocking I/O.</li>
<li>Reactive Streams back pressure.</li>
<li>High concurrency with fewer hardware resources.</li>
<li>Functional-style, fluent API that takes advantage of Java 8 lambdas.</li>
<li>Synchronous and asynchronous interactions.</li>
<li>Streaming up to or streaming down from a server.</li>
</ul>
<p>See <a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client" target="_blank" rel="noopener">WebClient</a> for more details.</p>
<h2 id="Ⅲ-Testing"><a href="#Ⅲ-Testing" class="headerlink" title="Ⅲ. Testing"></a>Ⅲ. Testing</h2><p>本节总结<code>spring-test</code>中为Spring MVC应用程序提供的选项。</p>
<ul>
<li>Servlet API Mocks:<br>Mock implementations of Servlet API contracts for unit testing controllers, filters, and other web components. See Servlet API mock objects for more details.</li>
<li>TestContext Framework:<br>Support for loading Spring configuration in JUnit and TestNG tests, including efficient caching of the loaded configuration across test methods and support for loading a <code>WebApplicationContext</code> with a MockServletContext.</li>
<li>Spring MVC Test:<br>A framework, also known as <code>MockMvc</code>, for testing annotated controllers through the <code>DispatcherServlet</code> (that is, supporting annotations), complete with the Spring MVC infrastructure but without an HTTP server.</li>
<li>Client-side REST:<br><code>spring-test</code> provides a <code>MockRestServiceServer</code> that you can use as a mock server for testing client-side code that internally uses the RestTemplate.</li>
<li><code>WebTestClient</code>:<br>Built for testing WebFlux applications, but it can also be used for end-to-end integration testing, to any server, over an HTTP connection. It is a non-blocking, reactive client and is well suited for testing asynchronous and streaming scenarios.</li>
</ul>
<h2 id="Ⅳ-WebSockets"><a href="#Ⅳ-WebSockets" class="headerlink" title="Ⅳ. WebSockets"></a>Ⅳ. WebSockets</h2><p>这一部分涵盖了对Servlet Stack、WebSocket消息传递(包括原始的WebSocket交互)、通过SockJS的WebSocket模拟以及通过STOMP作为WebSocket上的子协议的发布-订阅消息传递的支持。</p>
<h3 id="1-Introduction-to-WebSocket"><a href="#1-Introduction-to-WebSocket" class="headerlink" title="1. Introduction to WebSocket"></a>1. Introduction to WebSocket</h3><h3 id="2-WebSocket-API"><a href="#2-WebSocket-API" class="headerlink" title="2. WebSocket API"></a>2. WebSocket API</h3><h3 id="3-SockJS-Fallback"><a href="#3-SockJS-Fallback" class="headerlink" title="3. SockJS Fallback"></a>3. SockJS Fallback</h3><h3 id="4-STOMP"><a href="#4-STOMP" class="headerlink" title="4. STOMP"></a>4. STOMP</h3><h2 id="Ⅴ-Other-Web-Frameworks"><a href="#Ⅴ-Other-Web-Frameworks" class="headerlink" title="Ⅴ. Other Web Frameworks"></a>Ⅴ. Other Web Frameworks</h2><p>本章详细介绍Spring与第三方web框架的集成。<br>Spring框架的核心价值主张之一是支持选择。在一般意义上，Spring并不强迫您使用或购买任何特定的架构、技术或方法论(尽管它确实推荐一些)。可以自由选择架构、技术或与开发人员和他们的开发团队最相关的方法论可以说是在web领域表现得最为明显,在Spring提供了自己的web框架(Spring MVC和Spring WebFlux)的同时，也支持集成与一些流行的第三方web框架。  </p>
<h3 id="1-Common-Configuration"><a href="#1-Common-Configuration" class="headerlink" title="1. Common Configuration"></a>1. Common Configuration</h3><h3 id="2-JSF"><a href="#2-JSF" class="headerlink" title="2. JSF"></a>2. JSF</h3><h3 id="3-Apache-Struts-2-x"><a href="#3-Apache-Struts-2-x" class="headerlink" title="3. Apache Struts 2.x"></a>3. Apache Struts 2.x</h3><h3 id="4-Apache-Tapestry-5-x"><a href="#4-Apache-Tapestry-5-x" class="headerlink" title="4. Apache Tapestry 5.x"></a>4. Apache Tapestry 5.x</h3><h3 id="5-Further-Resources"><a href="#5-Further-Resources" class="headerlink" title="5. Further Resources"></a>5. Further Resources</h3><hr>
<p>Version 5.1.6.RELEASE<br>Last updated 2019-03-31 08:22:54 UTC</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring-Framework/" rel="tag"># Spring Framework</a>
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/29/backends/zookeeper/ZooKeeper(五) 分布式锁及ZooKeeper实现/" rel="next" title="ZooKeeper(五) 分布式锁的实现总结及ZooKeeper实现">
                <i class="fa fa-chevron-left"></i> ZooKeeper(五) 分布式锁的实现总结及ZooKeeper实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/06/backends/zookeeper/ZooKeeper(六) 一致性协议与分布式事务/" rel="prev" title="ZooKeeper(六) 一致性协议与分布式事务">
                ZooKeeper(六) 一致性协议与分布式事务 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.gif" alt="Javior Wang">
            
              <p class="site-author-name" itemprop="name">Javior Wang</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/index.html">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/scorego" title="GitHub &rarr; https://github.com/scorego" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/scorego-6" title="Zhihu &rarr; https://www.zhihu.com/people/scorego-6" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>Zhihu</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅰ-Spring-Web-MVC"><span class="nav-text">Ⅰ. Spring Web MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-DispatcherServlet"><span class="nav-text">1. DispatcherServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Context-Hierarchy"><span class="nav-text">1.1 Context Hierarchy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Special-Bean-Types"><span class="nav-text">1.2 Special Bean Types</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-Web-MVC-Config"><span class="nav-text">1.3 Web MVC Config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-Servlet-Config"><span class="nav-text">1.4 Servlet Config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-Processing"><span class="nav-text">1.5 Processing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-Interception"><span class="nav-text">1.6 Interception</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-Exceptions"><span class="nav-text">1.7 Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Chain-of-Resolvers"><span class="nav-text">A. Chain of Resolvers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Container-Error-Page"><span class="nav-text">B. Container Error Page</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-View-Resolution"><span class="nav-text">1.8 View Resolution</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Handling"><span class="nav-text">A. Handling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Redirecting"><span class="nav-text">B. Redirecting</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-Forwarding"><span class="nav-text">C. Forwarding</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#D-Content-Negotiation"><span class="nav-text">D. Content Negotiation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-Locale"><span class="nav-text">1.9 Locale</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Time-Zone"><span class="nav-text">A. Time Zone</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Header-Resolver"><span class="nav-text">B. Header Resolver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-Cookie-Resolver"><span class="nav-text">C. Cookie Resolver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#D-Session-Resolver"><span class="nav-text">D. Session Resolver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#E-Locale-Interceptor"><span class="nav-text">E. Locale Interceptor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-Themes"><span class="nav-text">1.10 Themes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Defining-a-theme"><span class="nav-text">A. Defining a theme</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Resolving-Themes"><span class="nav-text">B. Resolving Themes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-Multipart-Resolver"><span class="nav-text">1.11  Multipart Resolver</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Apache-Commons-FileUpload"><span class="nav-text">A. Apache Commons FileUpload</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Servlet-3-0"><span class="nav-text">B. Servlet 3.0</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-Logging"><span class="nav-text">1.12 Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Sensitive-Data"><span class="nav-text">A. Sensitive Data</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Filters"><span class="nav-text">2. Filters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Form-Data"><span class="nav-text">2.1 Form Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Forwarded-Headers"><span class="nav-text">2.2 Forwarded Headers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Shallow-ETag"><span class="nav-text">2.3 Shallow ETag</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-CORS"><span class="nav-text">2.4 CORS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Annotated-Controllers"><span class="nav-text">3. Annotated Controllers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Declaration"><span class="nav-text">3.1. Declaration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-AOP-Proxies"><span class="nav-text">A. AOP Proxies</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Request-Mapping"><span class="nav-text">3.2 Request Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-URI-patterns"><span class="nav-text">A. URI patterns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Pattern-Comparison"><span class="nav-text">B. Pattern Comparison</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-Suffix-Match"><span class="nav-text">C. Suffix Match</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#D-Suffix-Match-and-RFD"><span class="nav-text">D. Suffix Match and RFD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#E-Consumable-Media-Types"><span class="nav-text">E. Consumable Media Types</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#F-Producible-Media-Types"><span class="nav-text">F. Producible Media Types</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G-Parameters-headers"><span class="nav-text">G. Parameters, headers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#H-HTTP-HEAD-OPTIONS"><span class="nav-text">H. HTTP HEAD, OPTIONS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I-Custom-Annotations"><span class="nav-text">I. Custom Annotations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#J-Explicit-Registrations"><span class="nav-text">J. Explicit Registrations</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Handler-Methods"><span class="nav-text">3.3 Handler Methods</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Method-Arguments"><span class="nav-text">A. Method Arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Return-Values"><span class="nav-text">B. Return Values</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-Type-Conversion"><span class="nav-text">C. Type Conversion</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#D-Matrix-Variables"><span class="nav-text">D. Matrix Variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#E-RequestParam"><span class="nav-text">E. @RequestParam</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#F-RequestHeader"><span class="nav-text">F. @RequestHeader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G-CookieValue"><span class="nav-text">G. @CookieValue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#H-ModelAttribute"><span class="nav-text">H. @ModelAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I-SessionAttributes"><span class="nav-text">I. @SessionAttributes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#J-SessionAttribute"><span class="nav-text">J. @SessionAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#K-RequestAttribute"><span class="nav-text">K. @RequestAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#L-Redirect-Attributes"><span class="nav-text">L. Redirect Attributes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#M-Flash-Attributes"><span class="nav-text">M. Flash Attributes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#N-Multipart"><span class="nav-text">N. Multipart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#O-RequestBody"><span class="nav-text">O. @RequestBody</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P-HttpEntity"><span class="nav-text">P. HttpEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q-ResponseBody"><span class="nav-text">Q. @ResponseBody</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#R-ResponseEntity"><span class="nav-text">R. ResponseEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S-Jackson-JSON"><span class="nav-text">S. Jackson JSON</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-Model"><span class="nav-text">3.4 Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-DataBinder"><span class="nav-text">3.5 DataBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-Exceptions"><span class="nav-text">3.6 Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-Method-Arguments-1"><span class="nav-text">A. Method Arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Return-Values-1"><span class="nav-text">B. Return Values</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-REST-API-exceptions"><span class="nav-text">C. REST API exceptions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-Controller-Advice"><span class="nav-text">3.7 Controller Advice</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-URI-Links"><span class="nav-text">4. URI Links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Asynchronous-Requests"><span class="nav-text">5. Asynchronous Requests</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-CORS"><span class="nav-text">6. CORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Web-Security"><span class="nav-text">7. Web Security</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-HTTP-Caching"><span class="nav-text">8. HTTP Caching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-View-Technologies"><span class="nav-text">9. View Technologies</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-Thymeleaf"><span class="nav-text">9.1 Thymeleaf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-FreeMarker"><span class="nav-text">9.2 FreeMarker</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-View-Configuration"><span class="nav-text">A. View Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-FreeMarker-Configuration"><span class="nav-text">B. FreeMarker Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-Form-Handling"><span class="nav-text">C. Form Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#⑴-The-Bind-Macros"><span class="nav-text">⑴ The Bind Macros</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑵-Simple-Binding"><span class="nav-text">⑵ Simple Binding</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑶-Input-macros"><span class="nav-text">⑶ Input macros</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑷-Input-Fields"><span class="nav-text">⑷ Input Fields</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑸-Selection-Fields"><span class="nav-text">⑸ Selection Fields</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑹-HTML-Escaping"><span class="nav-text">⑹ HTML Escaping</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-Groovy-Markup"><span class="nav-text">9.3 Groovy Markup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-4-Script-Views"><span class="nav-text">9.4 Script Views</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-5-JSP-and-JSTL"><span class="nav-text">9.5 JSP and JSTL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-6-Tiles"><span class="nav-text">9.6 Tiles</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-RSS-and-Atom"><span class="nav-text">9.7 RSS and Atom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-8-PDF-and-Excel"><span class="nav-text">9.8 PDF and Excel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-9-Jackson"><span class="nav-text">9.9 Jackson</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-10-XML-Marshalling"><span class="nav-text">9.10 XML Marshalling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-11-XSLT-Views"><span class="nav-text">9.11 XSLT Views</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-MVC-Config"><span class="nav-text">10. MVC Config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-HTTP-2"><span class="nav-text">11. HTTP/2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅱ-REST-Clients"><span class="nav-text">Ⅱ. REST Clients</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-RestTemplate"><span class="nav-text">1. RestTemplate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-WebClient"><span class="nav-text">2. WebClient</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅲ-Testing"><span class="nav-text">Ⅲ. Testing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅳ-WebSockets"><span class="nav-text">Ⅳ. WebSockets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Introduction-to-WebSocket"><span class="nav-text">1. Introduction to WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-WebSocket-API"><span class="nav-text">2. WebSocket API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SockJS-Fallback"><span class="nav-text">3. SockJS Fallback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-STOMP"><span class="nav-text">4. STOMP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ⅴ-Other-Web-Frameworks"><span class="nav-text">Ⅴ. Other Web Frameworks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Common-Configuration"><span class="nav-text">1. Common Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JSF"><span class="nav-text">2. JSF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Apache-Struts-2-x"><span class="nav-text">3. Apache Struts 2.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Apache-Tapestry-5-x"><span class="nav-text">4. Apache Tapestry 5.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Further-Resources"><span class="nav-text">5. Further Resources</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Javior Wang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
